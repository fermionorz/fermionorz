<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>家用存储解决方案</title>
      <link href="/2024/11/01/%E5%AE%B6%E7%94%A8%E5%AD%98%E5%82%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/11/01/%E5%AE%B6%E7%94%A8%E5%AD%98%E5%82%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ebd790ced0103315029846115f79082818e8e300bd2b6746542416e5f33c9b8c">aa5f8cf5ba490e112c72ff5b98fb71df54f71447343d7362befbb79a70e723ff9c79b0ee8ceae089cdf0eff2716173d40ec947a9cb928fd2ff5667a76be6547d4ab0de18ec5c386496af0da9ff529e7be202acd760aa8faf77a224558a09f98d45c46a10c4ecaecde4bd932a30c1654bef533e287565c468f08eb2389cadfebe21f3d499e154c8a3e89cdf00ccb96b5901a40b235295588a14681a0a0dc8a3596364f596c4f3fe965bfbe396f25f69a26429d8296749725f9a78e8a36d25fcf0f0064bed8f70860e091211d31457074aa55dc812a00c8814b61d537eb52297b7dc141a30e34056438a93849711f54153f1ececff30a0fe137373fea3c7462063180b605c9b851b1e4b89f1e0b1fd024e0166ed1c722be1e4273b344ff3e8c5d190299e91373b9cf1f87537ffe500c9b2c6abd6b7cce3e422d5ef7cb569062011f1b65b429064388707c27f5ec0d00ea57e9be32d4cb6a3bd7b693728af1b7cc06dbbaccefd83320814e70fc441aa7c99d6702510668fdece0cc6ef157c0f0586e05680c66eb69b5b3efbb58dc80ddc6ecdf4cb2e85b5dfcca0da4156387f9db2f1c32f855ef419909cb5e3ba57230a1be8ea814269aa2a5ed04ac84c14f5546947ffdb711b24565def26c94a5168e4002206cf67be61ab9c90e98379b189919baf19a4617a1c0cbf2524862fb30ab571566319f9adad0066687aaca24001f3c1c9fe6a43f430fc0263c404fc99b25044b9db51d4c2e2b425dea390783473beea4264377c56f09abf51b500ad7f104d38407e63d00ecb5e6106775a51452cc6880d0b227f616d8fdf646beb2aeb008e086687cecac06354adba96220c3a892c289d9c577abf070e9777d63a065a19472479be2f85a569eba4930ac77d09802479e8f7526c0d2af66a7d87f02a29722a2314dd568af71385c2e7847e9b4e3a378fdc48c181ec7ed312092f4e391e0b1fd3a38a9d65b9daab080a25cfae5908a20cbefa9f711889a1be06560a554ae521ae786d7167fd6dd75d44f3704f71e409b3fa7e45d057b128bb061f6179a585e844d663e4202abf95a50bfb4991eacf12c4e991b84998b4fa36f8e3a3e9715d714be8eed7c6dff14ac3450267e2b8fdbe74b8527563a104b1f4308af8de0cab650245f168c79712dcd5e6bcb451ddf1ffff373c824c44cbddf6f6866c40d20122aefd29309bfe77d96e97d7cf99fbd5a50cf440e2b4864f1bc56b0a73b4baede36bf14f19c6bb59054884c752d87955b7e584c7668b380360d9a754f7b9b61de7152290c238ee0cbd87c62845c8f8bb9894089ad6f9432bceed41ebaff3ec4b672c0c4793815f0a64daa41a28598807b579bcb91f3247b3b38f256c6219a05192fd2d54c7cc9c16fe89dfd2d1f6b2df579a1ad3ee19a86852718d0072ef276c6f9f932059b711c94052af66e9c29368f0435a45a2676fb2f1c2477cbbecf3a3948cbcdc70dc590d6a910a4814ce539e4ce644e90326d91460e6e2892e7da403dc0d689dc29bb5acef395b3ed7011627fe938df5abf5c70ba95bda594567e2eef21d8bf5f3ad7434da581053af98c30f30cd012f5bc1de1360083548188dcc39232790c84d74ef99b0b427dcabe1486a0ff926aaa635a39d18a38f0004822ebe05d09100acbe5662fca6a68201b9900b337c36fcd3f4f90bd35d2016c6c51400dcf527dc96c049ffdb58c8ab796608eb0da475dec3ca9f5ab2a7fa7d4dccfdf92c8d8b57f7df6e76f076377a22b8e926b817695d806ca620f3864a81a0bff5f828a80bd7e62b4203b4aa390d5fa384ef758e79dc11dcdb5371ebbff9ea843930d68b36422f10790a3b9db7d34b8cc1985d7de85539d88fd0bc452bc4a58ec46b9a606dc4b7bf6cc6b30cded7ce4e0e63ec065c55f0d4fbb8cb26c6dc6f43a70adac2680f0d8a08f7705e34beacdd0681a69209f5d3d8b5d9dce91aadbc94b95d1749924ebffe19e3930a033097e50afba61f784f231abf41c5e8de60a13877ea66876cca1ea36167da5de7f30827244b33feda486b555df41f704d2c0ef04c0c02e220d1a8cb5d8ea45169e1bd00861b5a160d9c69f60bb6f8039f4d52c57842cca7b0ce1dc2f8a0c542680aa74fcdfc97c4efa6f03071cb0fe0d8336214bfbd814951229a0b3666035192700b3967b44b33daa8ae0e8cb4b6516ec2aad33b99ffa34b339d5845c9c0deedb8c344c621bd14693112cc6165e1f35bd9ae049d96bc0a95aea3614e06b6d291418de4a63f2ae3308ec21096a9e60d1a1515ec106ecbfc7ba357eb2c632ab1e2a406a1ec8d19b2d827edd931aa6eb1400521cc07f9742169841d66ff97d1d2b87da4920dffef29fd575d0e6fc5b74b2a39a38dedc2ea8771e7dfc951b2b3f35df77aaf67ac65b03cf65306bd4be89a88d81f00000105ca0fd2352d418be5cce82693344d57a7ab765eb7d988cf2036f966d5643fc0a9bb77550fc3d54c9d9a4a4a209feede020952dfc1f743a6e1053f141114e820a37410bbdd7a52f82189236580a2b550330ba7e9b53131a5e47cf4215a6d4e7b7fea2b9ac9de06d1e98fd31f2f2daf2bbc2a6a9882c2dfaeb729c7ec22417792c31aaad7caad3bccd5b9e826c8a6aa0ac1b26cbaf927eb82906402d632c34cf2d598283a06be2b9f642ec42d9e849043577cc4b8b7efeea06fb1926baf5b982eddf8dd5d495a95b48b7ba243285ff8546bb13443ae96d7bea2309f17457a27c35a436a58cbbe7353e64ec965f76480e2c6ecaccf4fa1d80f1f8c3a292ac6c1bf1a64d79b9f09058cfac6251a736d6d038c50180a8437d71d9869c7781bd21db7d3fca448620531b70474f4ec279f3c88d0c6b6b829a9bc13e77f0b7d5467e20160ff0fcbc483473ab34e72c81717e512e682b45a962ba49a0ce4c3f28ca16bfca126ca9915fe1c47983079cbfe319e01dfb40b6785f84b01cb706fff7b578849893086060517b8171c0f9d7736d244e1cbf9294d2af6e5bc125767decd752d6ca5e9f80256e49c1f23d9d69d9e7249608ee268b97b3725d6c86c2206feb80bae159e3013e90a3b038f22c56495e88c4e6f67d217c6c15d33413e578c85e8f6aa40e4c8652305db135878856827161e391ec3fde8841c3ce37e08336c45f678b4bd504d979de06936d31b73a08be24b4480a7795e24b17703038dac20612e20bfe9e6a3311e05f19153b8fb282d50635825104cc15ade42c0f2dfc84433d6fed8ef03e36c8ba2413a25fad9a13324609a9dd5eddb8e0e1f99be0a2d992a8c0b7cb257e0233f4e13628e79fba9b42b12fd295e471b7007455a0596df53253f12dd6f5dad2c5699dcdf12023c6b67c376e37bd748612d69f20e984799ce7aaa288fb8a5c87d0eafe056438a859e8492d1f7b2a598d5b3fab7d0e78d1bc2422cd1ac4d52e0d3167a6e9431d6c2c2c3f88aac9ac5725a2800c7eab22b78909d025c39a0fa36c6fb58ed2042b0814a6b8a20c25a68f1e526773928a58573127c73ffb75d97b53b41f8e3592ab3203a4e8c2f4ffa03824a71622634e33a1fbd0ed271abd9e919408b266e29a4d37200652b1f18a03c05f7be13ec9be5d18a0ceb2df2308e6b5caaf0c94e25d0659b330894e8a7effffde327e7a6f9ff585555392b527b0d74daae99aa9b41f7ab2d43a29753f04eb7451418e15a70cc629afc5060057afa9615dd6b40513ede66079062fa07800a59c7fbbf42aa412fb85b76583b8d7518b697ca43a33f345ed50670f7209a5a43ecbcec68ac94dc0f09298809d925d739d4338c33b522b48753f2963ea3111b6659b1af6600af7295bbc038c79efc211601ceb58a198fc0ec1425ec83b5ae0cc42591abb21966ae052508ecdfc03d669b2b37e238ffadf73753550f2b555f436dd40b8cdc7e280acc1f005dd8637e9d453407b4c894bdffa655fa840fdaad461c35bc760f5aaf9d3b5374faeb622c13f3e047718e074e5b2225f0ed3d43aa94fc185dfd8bc5671f5f75c48b14879d21d2e64eae38739e57e75f9e75a4b673ef0d7f2de37de3c23a9a1c5eca54ae7358f78ed017f1c040e9c55d77c6ec2fd63ec7b20dcf71b03cf01e5397c5fb3aab771edffdc62a1134df1c55fcab0ab8e613323c7ff022241c448f36b78e5e87a23b736dcc3ad70b34bdb3b738886bf56ffd1eb508fdf2d2596ba65ab138e55470c3a21728865a7c41e2596bbade76e539c3ebb6dbbb7042bde109141f6bf9b8cadd74a5d32c1361df5bf64bc3e1f7302170dddf38972474a0226dfd64087d4cc907d2aae64ae82565a090d01b26f7384490d24682b6b48413e6ac07e7c71c1155306cf99917cca8b15991a81a165cccdbfae94d6c25c90ca648ff53f9fe68260acab8f55216fb4112c6e136f3b0bb39f347b8e207be580e6a348a7ee00d17a774e104ca60a8d2e29e3a08cb736f49250edaeda373db06195e36c0377f19461a9b56a561716c44cc207283f8c0c80709795ee8499e8f3f93aba60a6c162c9a098f7868662910b07b16198876111d4790a77257f541a52af9561955562c73d939982af27cc58abf71bf56a6cd1368840cf9f299146e8f4d88be42a9a6ff04aedda13a424137d238bb3122cc0412ba554785137f65297290404b6e97e4bfd2801bf83f06646d3310b9527acacfe925dbd787b1dc1accdd4c39e8bf5cb9d638f67d4955d4d6cb80067cac2a5c371a4763ace013e3fd80138bd7be9edcba2f46f4cbde5ed4be90ab7890b254cc75b436147372d4c4f8333d14e9b25b90faf92519a7fd6571ff9ecb4019f8391b1036f9cc2d194e53854fbd0afff7d643997aa5ea657bf90f627519a3c344c70920a8c562e135adbc27ee61e06362ac95153973c8df0760a385009c7131f3bf203511b2c788718793d0876e17ee529b781fa83af164cebb710ebc972e6f729ef34a6184060bc15149584f5699534665408d92183099c53c1a92b892da6867a8b1c85bf75c14635dd31e63635f96b514fc77d69584308a04cd39</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC Linux 解决方案</title>
      <link href="/2024/10/29/PC%20Linux%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/10/29/PC%20Linux%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4ae0799af46e45fde7bcbc374fabeafbb9fa830ae33e1a87b9071056cab7d0d4">aa5f8cf5ba490e112c72ff5b98fb71df54f71447343d7362befbb79a70e723ff9c79b0ee8ceae089cdf0eff2716173d40ec947a9cb928fd2ff5667a76be6547d4ab0de18ec5c386496af0da9ff529e7be202acd760aa8faf77a224558a09f98d45c46a10c4ecaecde4bd932a30c1654bef533e287565c468f08eb2389cadfebe21f3d499e154c8a3e89cdf00ccb96b590cdb493b8867b058f6d578188643d54eb242eb3f97af337cf92b66d0a0648238a2b478efbc2fa807af9cc19c3a85905d44381891165dbb35be4b18b5f659a0a9f51c3fb2c34ec2d2ebd9c8f3720972712a1bf4650f9a84aa55870809c6b72df2df7e9cafec844e64dee5f9ac7683120e3b3f462e5211f359deb7d0e150c645490c4f38274e5b1f997fb0d526e6ad77a64d7efd7ca5b542875ff60493a88d78c8b860e592ea9991415823f13543a0a1d561bda7f70f7d988d05f38a18e14e248888ae1ea278fd1743d4cfc2c2601f3e1e24eef4174f371d5b00f533cfc11b1caa697c4b571fd2c33b06b5195b7f3797e9fc68df2e26f6334bffb8b960ca6150755a2350f78249486457507c3fbb12e183891eb60c45ad72fef171988349e16cc93df9f33f549868393c498676887bbef99ac7329baa0b2874af70f823d83058f92142dbf20a27b9c610ea518549467952faa0a874646f6b6e912decc0dad20f79be68d71e09c21597e23b59e291565972e50716f0721a5840add8f9c08eae005a8aa9b2eccdf71c11ac6f583ea29904743aff05abef9464c67e87078ae884767e23279dc84cf392a1630fb4f781a7dff64327b43f3d6ad8aeb462cf47d4b558c8ad2f515bb2564a182bba92446790ba7e321e4646557a0476225204e6e36a1ef0efdacdfc873cd253f07ccb4b16810f96ca6ba2c95d9bdfa62078c73957cb98912a37b835860d89fbb1e053fd08bc36f850d607286338461da8ad1215d8074de8d0aec47582c31411abb2f4483feb4d2a9065997dc371c632725d69374eac9dda6075e2894e034f6fa36526f6abcfc5bb5e44dbd466ba9ba762db7b55a5dee6f36bf820938503c52e3d5cdf1bc2bfcea62bbf33436b09d5adc1410c739ff78e9853341957fac7fce4d069900101b7637c25a4f9c3f5d8c41e96e207083f6bbdde8445ae3fd6a61eaa5f381ac2b0a760cba255c23f137124422e6ca3e9da29401210fe14ccb406cf27522b0dc63cba75579ca7f5544cb18f7d36298247cc116de6f74cd90192193a887a8f14e8aece6c034eb59b0a7b9055be7dcc98d63b98e13b241490c5610547d55158611014d2a26f28033353a04c74b91a88171d89b2a466eaf41e8a289882d94045bfbce2b3ad2062eca85e6d19cb2df9918cc62c27db4a9c227d7b3b2d64e6fe1c03de7c0402add0798f2816695e4d788d56d9becfc533212efc38f8db446345ff223129cd21477d323f7077616f2e7efe263174110ea99fef40cbaf7d2f936846a6579386f9df0a06e1de57a5e4b677db25b43d0af8b37db0b36e9041c8dbaad879e1fdd0d8f6a5120f5afa559f1017ec52ab37a60adcc56463290a99b734d430290b85564d9896b4ae38eb17c7963ff6c2daac4ab4b460a7ddc3a4b71b6e5e6ea126cb6015185c541b8337dc17ae1c3bf222743340cec4f7e84d0ab5774610308dcd0af9fccf8dd2f6998533671202c2c5ba29698e64b2a928e144d3c0bc6ff8fc23e6a2d89dbdd8fb9f5dda38851a1fdbeca5640d309c52e611f92ccdbd1a64a24f6346ba4c07917064f1e95221e8f5ea9f78028c6cae270f4fc88503cf6997a097fa725445fd63392f75866ddc1f57a662fa362960fbd8a8c95c5e81f495614f8ee385245005ca88701ccb67897fc072e9feadd07fe271700c317bca588cea62ccd580497a2cad663d3ce4934cf461c74e93b3bb0426d45cc1e79c647870e656171e95932c6f212d79b15209ef4220bb7f9a983a14adc4a185d609e8bc42571359cfcd2148b4524a82ff552ee741ea98185db59be306d053fcb657f680a631e936515f512724bb84597713e8000ee6eacf2424b3ff112bdd8a4171a4f5190133077cbef444e18753e15fa3f67b72ecc4e801857e3333e88e643b1769faf576a1d79df1bba88842d3c1e2d26dabfaaeeb1fe98cf7774fbcdb205d2f4383a956b505a633c508c18d31a03bd1c2158f74919a1c05464223e826050fbd325d0f93b7f986da7567d9ea2b0857da0fe89366df2e85fba814eda690cf5214989d18c41add3390d43699d7a662f7e536fc861db193d4191dab27a96a503e4071f7f4372f23a64609d5e0296ea2a7ed50edca57bf7100c2ecdecbdec33fc2b99503ec99e14239bc628aa8bc8359f75aa9e81e5bfc953884c2ce19247dd2bc277b74d24269559a8dd32ff507fbf87ff0d197f8db7745299b7cdee7a7b525235974d65a705761d4b9c39f339c8a7942167c63ba7b3cde59a0991529b995ea1476065d0ca4cea24afcb5dbf9bfa34ae1a3f6e047731adf3bd4841f4b5d12ea482ebb0582fcc74b7ae8baa47aee64ea7753e37b60ecf797f731b41058f888ccc5c15a68effd2507c553aa00e0a40d116d5200dd3a51df95032dc7ff689488b1fd0ceaac8b55aa254a6d81ec1c0905f20b71cfd50472092cc391c5b4e410446edbe43e24cce4724a894efa0ba9329bf27d112034f5b81959f8b87ec3527b8666aedecd46cecc0a8724b5e50faee6161576c053dff7e275dcc6c6a306ebf47f0bceae56fe5cc8fd40b4ce97f21ced3deec2020342b15c27bdd1a99b8fb44346146c81045e31ff643768fb393a68252844f9c09b807ebf99ceda39982040bdefaf0e212af0bac9cab8a22fbd6553699e0587c8b3d90e884cdc1f87d87707f5e98cd67298a090c3c153124728ad56b7b3d4e3cd25f3abfb1df47a1dc3348ef23aecebc4ce90cf7d572f36e12ce8f9375ce5b8c0d749d2e8e8e3a0dbcab0e423fd08ac1264216dfcfe84a0b79622409df09ab5ce19eeb1bea2ea6137351f2aa9bec0b6d42739069a72225bcc9838635f556ec8fd9a415651f21c877ef9d5e34d7d40809a0e6c05bafbaf8af8c24113c79b874a4870b9819778e0851c7fdb46b8fd27cf2b1f687427d0ec84f82b83be1da3d11ff31fc4c44b13a9b61b5046a509335b79fb1d05cd277ab004cf607ace460a0d9c6e995e6504c9e6df172c7007b1e4657f7f34df1af19b7ab756e82ce8d8b20ee170b5e3c4b2ecebf31ec23e5cff9233fd52b139aa286f3c67b016266d842b0738081c4b2987c91394aba5f3835a1788eb4c9b49549902061467ecd62831790c049bbfa153941bb12d90309fb97165661f9f8eda442fb0c460c0b5a8c47c915e7396c847443226a932f04f9471d4c6e4ea654a566d57f788806e8ae3d0e9c66aabf32a710e25b5cb0c90773de49e49d02883fe35e5630715d02a7e90164bf9fba3a0780d5047cd89cbdcfa01bb993ffa72a04749c12bb0ad0df8d7639618c950cdec6e00e75c5bbba229b936a4c793e6e2617321dea2fb4d24ae474ecefa0d08835039deb25a235829b2b360a50453e90317ff2855a6b499388ab01b2f6a31836d787429a7611a0e2c91f4ea47e11672398f3b8a0a473492bf6563e8dfcb27ab7b0bd5f88b8637755916868d46f7636171cec5aad5ab6409612ea0fc49d5403fed9d52dc615d2f894b0819350bf89b19f6cbc6698bbe5caa47c1b4a6f2bcda6952984c26e691528c6cb4d7129b18e6dca2e4a5231a60d8a7f2de59e2d4ec5df57030c148a5e35d34617775d8e3df46ebd530d018039d1eff39e863df3cbe85a0b41cb54a53bc989f24f4bedf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Maldev - ITA 隐藏与混淆</title>
      <link href="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/"/>
      <url>/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ITA(Import Table Address) 包含有关 PE 文件的信息，例如使用的函数名以及 DLL，此类信息常用于对二进制文件进行标记和检测。例如：</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241024083658530.png" class=""><p>可以看到，这个 PE 文件导入了 <code>CreateRemoteThread</code>、<code>OpenProcess</code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code> 等函数，Shellcode 加载流程尽收眼底。</p><p>想要隐藏这些内容，可以使用 <code>GetProcAddress</code>、<code>GetModuleHandle</code> 或 <code>LoadLibrary</code> 在运行时动态加载这些函数。</p><p>但这又会出现其他问题。</p><ul><li>动态导入的函数相关字符串会出现在 PE 文件中，这个可以用于签名检测</li><li><code>GetProcAddress</code> 和 <code>GetModuleHandle</code> 函数的导入信息也会出现在 ITA 中</li></ul><p>想隐藏字符串，那只能通过替换，可以通过字符串加密、Hash 运算等方法；对于 <code>GetProcAddress</code> 和 <code>GetModuleHandle</code> 函数的信息，可以通过自实现来隐藏。两者结合。</p><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>Hash 函数的选择，最好是能够轻量实现，并且分布均匀（以防冲突），这里的 Demo 选用 <code>JenkinsOneAtATime32Bit</code> 算法，实现来自 <a href="https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringJenkinsOneAtATime32Bit.cpp">VX-API GitHub 仓库</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))</span></span><br><span class="line">UINT32 <span class="title function_">HashStringJenkinsOneAtATime32BitA</span><span class="params">(_In_ PCHAR String)</span></span><br><span class="line">&#123;</span><br><span class="line">SIZE_T Index = <span class="number">0</span>;</span><br><span class="line">UINT32 Hash = <span class="number">0</span>;</span><br><span class="line">SIZE_T Length = <span class="built_in">strlen</span>(String);</span><br><span class="line"><span class="keyword">while</span> (Index != Length)</span><br><span class="line">&#123;</span><br><span class="line">Hash += String[Index++];</span><br><span class="line">Hash += Hash &lt;&lt; <span class="number">7</span>; <span class="comment">// 这里的种子可以更改</span></span><br><span class="line">Hash ^= Hash &gt;&gt; <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">Hash += Hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">Hash ^= Hash &gt;&gt; <span class="number">11</span>;</span><br><span class="line">Hash += Hash &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="keyword">return</span> Hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了灵活和方便使用，设置了 <code>HASHA</code> 宏。</p><h2 id="实现-GetModuleHandle"><a href="#实现-GetModuleHandle" class="headerlink" title="实现 GetModuleHandle"></a>实现 GetModuleHandle</h2><p><code>GetModuleHandle</code> 函数用于在内存中检索指定 DLL 的句柄。函数返回 DLL 的句柄 (<code>HMODULE</code>) 或 <code>NULL</code> 。</p><h3 id="GetModuleHandle-原理"><a href="#GetModuleHandle-原理" class="headerlink" title="GetModuleHandle 原理"></a>GetModuleHandle 原理</h3><p><code>HMODULE</code> 数据类型是加载的 DLL 的基地址，表示 DLL 在进程地址空间中的位置。因此，替换函数的目标是检索指定 DLL 的基地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">  BYTE                          Reserved1[<span class="number">2</span>];</span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line">  BYTE                          Reserved2[<span class="number">1</span>];</span><br><span class="line">  PVOID                         Reserved3[<span class="number">2</span>];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr; <span class="comment">// 该结构包含关于进程加载模块的信息。</span></span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  PVOID                         Reserved4[<span class="number">3</span>];</span><br><span class="line">  PVOID                         AtlThunkSListPtr;</span><br><span class="line">  PVOID                         Reserved5;</span><br><span class="line">  ULONG                         Reserved6;</span><br><span class="line">  PVOID                         Reserved7;</span><br><span class="line">  ULONG                         Reserved8;</span><br><span class="line">  ULONG                         AtlThunkSListPtr32;</span><br><span class="line">  PVOID                         Reserved9[<span class="number">45</span>];</span><br><span class="line">  BYTE                          Reserved10[<span class="number">96</span>];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved11[<span class="number">128</span>];</span><br><span class="line">  PVOID                         Reserved12[<span class="number">1</span>];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure><p>PEB 结构的 <code>PEB_LDR_DATA Ldr</code> 成员包含进程中加载的 DLL 的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB_LDR_DATA &#123;</span><br><span class="line">  BYTE       Reserved1[8];</span><br><span class="line">  PVOID      Reserved2[3];</span><br><span class="line">  LIST_ENTRY InMemoryOrderModuleList;  // 内存中模块列表</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure><p>对应 <code>LIST_ENTRY</code> 结构是一个双向链表，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025085631337.png" class=""><p>微软文档中说明，<code>_PEB_LDR_DATA</code> 的 InMemeoryOrderModuleList 成员包含进程加载模块的双向链表的头部。列表中的每个项都是指向 LDR_DATA_TABLE_ENTRY 结构的指针。并且给出了 <code>_LDR_DATA_TABLE_ENTRY</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    PVOID Reserved1[<span class="number">2</span>];</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    PVOID DllBase;     <span class="comment">// DLL 基地址</span></span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    UNICODE_STRING FullDllName;  <span class="comment">// 已加载 DLL 模块的文件名</span></span><br><span class="line">    BYTE Reserved4[<span class="number">8</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">3</span>];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CheckSum;</span><br><span class="line">        PVOID Reserved6;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>因此，需要关注的两个重点变量已经找到</p><ul><li>DLL 基地址: PEB -&gt; Ldr -&gt; InMemoryOrderModuleList -&gt; Flink -&gt; DllBase （这个其实不是）</li><li>DLL 文件名: PEB -&gt; Ldr -&gt; InMemoryOrderModuleList -&gt; Flink -&gt; FullDllName</li></ul><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HMODULE <span class="title function_">Yes_GetModuleHandle</span><span class="params">(IN LPCWSTR szModuleName)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 peb</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 <span class="comment">// 如果编译为 x64</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readgsqword(<span class="number">0x60</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32 <span class="comment">// 如果编译为 x32</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readfsdword(<span class="number">0x30</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 获取 Ldr</span></span><br><span class="line">PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);</span><br><span class="line"><span class="comment">// 获取链表中的第一个元素，其中包含第一个模块的信息 </span></span><br><span class="line">PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pDte-&gt;FullDllName.Length != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Found Dll %-15ls DLLBase: 0x%p Reserved2[0]: 0x%p \n&quot;</span>, pDte-&gt;FullDllName.Buffer, pDte-&gt;DllBase, pDte-&gt;Reserved2[<span class="number">0</span>]);</span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">GetModuleHandleH(<span class="string">&quot;&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025093521044.png" class=""><p>对比 Process Hacker 打开的进程信息</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025093502653.png" class=""><p>发现 <code>pDte-&gt;Reserved2[0]</code> 成员是需要的 DLL 基地址。</p><p>现在枚举 DLL 文件名，通过 Hash 校验来确定目标 DLL 基地址。可以实现对函数名进行 Hash 计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showHash</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">char</span> dllName;</span><br><span class="line"><span class="type">char</span>* dllList[DLL_NUM] = &#123;</span><br><span class="line"><span class="string">&quot;NTDLL.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;USER32.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;KERNEL32.DLL&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DLL_NUM; i++) &#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; dllList[i][j] != <span class="string">&#x27;.&#x27;</span>; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dllList[i][j]);</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">7</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t0x%0.8X \n&quot;</span>, HASHA(dllList[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025100804977.png" class=""><p>这样比较方便去定义，并且统一转换成大写。</p><p>接下来更新一下 <code>Yes_GetModuleHandle</code> 函数为 <code>Yes_GetModuleHandle_FromHash</code></p><p>这里大小写使用三元运算符实现，可以定义为一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_MAX_PATH256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TO_UPPER(C) C &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; C &lt;= <span class="string">&#x27;z&#x27;</span> ? C + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span> : C</span></span><br><span class="line">HMODULE <span class="title function_">GetModuleHandleH</span><span class="params">(IN UINT32 ui32DllHash)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64<span class="comment">// 获取 x64 peb</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readgsqword(<span class="number">0x60</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32<span class="comment">// 获取 x86 peb</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readfsdword(<span class="number">0x30</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);<span class="comment">// 获取 Ldr</span></span><br><span class="line">PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pDte-&gt;FullDllName.Length != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">CHAR UpperCaseDllName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pDte-&gt;FullDllName.Length; i++)<span class="comment">// 转化成大写</span></span><br><span class="line">UpperCaseDllName[i] = (CHAR)TO_UPPER(pDte-&gt;FullDllName.Buffer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ui32DllHash == HASHA(UpperCaseDllName))<span class="comment">// 判断 Hash 是否一致</span></span><br><span class="line"><span class="keyword">return</span> pDte-&gt;Reserved2[<span class="number">0</span>];<span class="comment">// 返回 DLL Base Address</span></span><br><span class="line"></span><br><span class="line">pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);<span class="comment">// 链表下一节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下效果，没啥问题。</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025103841263.png" class=""><blockquote><p>上文的代码中关于 <code>GetModuleHandle</code> 的实现使用了 <code>winternl.h</code> 头文件，这里可以使用 <a href="https://www.nirsoft.net/">NirSoft</a> 与 <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpebteb.h">Process Hacker</a> 的结构体来代替。最终效果 仅需导入 <code>&lt;windows.h&gt;</code> 头文件。</p></blockquote><h2 id="实现-GetProcAddress"><a href="#实现-GetProcAddress" class="headerlink" title="实现 GetProcAddress"></a>实现 GetProcAddress</h2><p><code>GetProcAddress</code> 函数从 DLL 句柄中获取导出函数的地址。如果未找到函数名，返回 <code>NULL</code>。</p><h3 id="GetProcAddress-原理"><a href="#GetProcAddress-原理" class="headerlink" title="GetProcAddress 原理"></a>GetProcAddress 原理</h3><p>要访问导出的函数，需要访问 DLL 的导出表并在其中循环查找目标函数名称。</p><p>PE 头模块时提到，导出表是定义为 <code>IMAGE_EXPORT_DIRECTORY</code> 的结构。<a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#export-directory-table">微软文档</a></p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025110446188.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;   <span class="comment">// 导出地址表中的条目数量</span></span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">DWORD AddressOfFunctions;    <span class="comment">// 函数地址（相对于镜像基地址的 RVA）</span></span><br><span class="line">DWORD AddressOfNames;        <span class="comment">// 名称地址（相对于镜像基地址的 RVA）</span></span><br><span class="line">DWORD AddressOfNameOrdinals; <span class="comment">// 名称序号地址（相对于镜像基地址的 RVA）</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>需要关注的就是最后三个成员</p><ul><li><code>AddressOfFunctions</code> - 指定导出函数地址数组的地址。</li><li><code>AddressOfNames</code> - 指定导出函数名称地址数组的地址。</li><li><code>AddressOfNameOrdinals</code> - 指定导出函数的序号数组的地址。</li></ul><h3 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress</span><span class="params">(IN HMODULE hModule, IN LPCSTR lpApiName)</span> &#123;</span><br><span class="line">PBYTE pBase = (PBYTE)hModule;<span class="comment">// 转化一下</span></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;<span class="comment">// 获取 DOS 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);<span class="comment">// 获取 NT 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;<span class="comment">// 获取可选头</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<span class="comment">// 获取导出目录</span></span><br><span class="line"></span><br><span class="line">PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);<span class="comment">// 获取函数名称数组指针</span></span><br><span class="line">PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);<span class="comment">// 获取函数地址数组指针</span></span><br><span class="line">PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);<span class="comment">// 获取函数序号数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) &#123;</span><br><span class="line"></span><br><span class="line">CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);<span class="comment">// 获取函数的名称</span></span><br><span class="line">WORD wFunctionOrdinal = FunctionOrdinalArray[i];<span class="comment">// 获取函数的序号</span></span><br><span class="line">PVOID pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[wFunctionOrdinal]);<span class="comment">// 通过函数序数值获取函数地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[ No.%0.4d ] addr：0x%p Name：%s \n&quot;</span>, wFunctionOrdinal, pFunctionAddress, pFunctionName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025122811847.png" class=""><p>效果还可以，与 GetModuleHandle 一样，可以加入 Hash 校验，来确定目标函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress_FromHash</span><span class="params">(IN HMODULE hModule, IN UINT32 ui32FuncHash)</span> &#123;</span><br><span class="line">PBYTE pBase = (PBYTE)hModule;<span class="comment">// 转化一下</span></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;<span class="comment">// 获取 DOS 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);<span class="comment">// 获取 NT 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;<span class="comment">// 获取可选头</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<span class="comment">// 获取导出目录</span></span><br><span class="line"></span><br><span class="line">PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);<span class="comment">// 获取函数名称数组指针</span></span><br><span class="line">PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);<span class="comment">// 获取函数地址数组指针</span></span><br><span class="line">PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);<span class="comment">// 获取函数序号数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++)</span><br><span class="line"><span class="keyword">if</span> (HASHA(pBase + FunctionNameArray[i]) == ui32FuncHash)<span class="comment">// 比较函数名的 Hash</span></span><br><span class="line"><span class="keyword">return</span> (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);<span class="comment">// 通过函数序数值获取函数地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Main 函数中调用检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL32        0xD4D19933</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LoadLibraryA                    0x000000000FA9B202</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] WinApi: 0x%p - HashApi: 0x%p Func: %s&quot;</span>, GetProcAddress(Yes_GetModuleHandle_FromHash(KERNEL32), <span class="string">&quot;LoadLibraryA&quot;</span>), Yes_GetProcAddress_FromHash(Yes_GetModuleHandle_FromHash(KERNEL32), LoadLibraryA), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025131445933.png" class=""><h2 id="动态加载-Win-Api"><a href="#动态加载-Win-Api" class="headerlink" title="动态加载 Win Api"></a>动态加载 Win Api</h2><p>目前已经实现了 GetModuleHandle 和 GetProcAddress，可以动态加载函数了，在加载之前，需要声明函数类型，以便在获取函数地址后进行强制转换。</p><p>Demo 计划实现一个代替 printf 函数的宏实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTA( STR, ... )        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (1) &#123;        \</span></span><br><span class="line"><span class="meta">        LPSTR buf = (LPSTR)pRtlAllocateHeap(pGetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ( buf != NULL ) &#123;        \</span></span><br><span class="line"><span class="meta">            int len = pwsprintfA( buf, STR, __VA_ARGS__ );        \</span></span><br><span class="line"><span class="meta">            pWriteConsoleA( pGetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );        \</span></span><br><span class="line"><span class="meta">            pHeapFree( pGetProcessHeap(), 0, buf );        \</span></span><br><span class="line"><span class="meta">        &#125;        \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure><p>其中用到了以下函数</p><ul><li>wsprintfA (user32.dll)</li><li>HeapFree (kernel32.dll)</li><li>RtlAllocateHeap (ntdll.dll)</li><li>GetStdHandle (kernel32.dll)</li><li>GetProcessHeap (kernel32.dll)</li><li>WriteConsoleA (kernel32.dll)</li></ul><p>另外还会用到 LoadLibraryA (kernel32.dll)，在某些情况进程中没有 user32.dll 时来加载它。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>按照声明格式写好模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span><span class="params">(WINAPI* fnLoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnHeapFree)</span><span class="params">(HANDLE hHeap, DWORD dwFlags, _Frees_ptr_opt_ LPVOID lpMem)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* fnRtlAllocateHeap)</span><span class="params">(PVOID HeapHandle, ULONG Flags, SIZE_T Size)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetStdHandle)</span><span class="params">(DWORD nStdHandle)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnWriteConsoleA)</span><span class="params">(HANDLE  hConsoleOutput, <span class="type">const</span> VOID* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID  lpReserved)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(WINAPIV* fnwsprintfA)</span><span class="params">(LPSTR unnamedParam1, LPCSTR unnamedParam2, ...)</span>;</span><br></pre></td></tr></table></figure><p>准备好 Hash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLL Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NTDLL              0x4898F593</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_USER32             0x81E3778E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_KERNEL32           0x367DC15A</span></span><br><span class="line"><span class="comment">// WIN API Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_LoadLibraryA       0x19F0EEAF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_wsprintfA          0x2AF0CBF4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapFree           0x1154459B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapAlloc          0x2F9B708A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_RtlAllocateHeap    0xF5613878</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetStdHandle       0x0C685B0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_WriteConsoleA      0x65304EA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetProcessHeap     0x3BCCFAC6</span></span><br></pre></td></tr></table></figure><p>创建全局函数指针变量，用 api_init 函数初始化所有函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">fnLoadLibraryA pLoadLibraryA;</span><br><span class="line">fnHeapFree pHeapFree;</span><br><span class="line">fnHeapAlloc pHeapAlloc;</span><br><span class="line">fnGetStdHandle pGetStdHandle;</span><br><span class="line">fnWriteConsoleA pWriteConsoleA;</span><br><span class="line">fnGetProcessHeap pGetProcessHeap;</span><br><span class="line">fnwsprintfA pwsprintfA;</span><br><span class="line">fnRtlAllocateHeap pRtlAllocateHeap;</span><br><span class="line"><span class="type">void</span> <span class="title function_">api_init</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule_Kernel32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_Kernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] K32_DLL Get Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pLoadLibraryA = (fnLoadLibraryA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA);</span><br><span class="line">pHeapFree = (fnHeapFree)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapFree);</span><br><span class="line">pHeapAlloc = (fnHeapAlloc)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapAlloc);</span><br><span class="line">pGetStdHandle = (fnGetStdHandle)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetStdHandle);</span><br><span class="line">pWriteConsoleA = (fnWriteConsoleA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_WriteConsoleA);</span><br><span class="line">pGetProcessHeap = (fnGetProcessHeap)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetProcessHeap);</span><br><span class="line"></span><br><span class="line">HMODULE hModule_User32 = Yes_GetModuleHandle_FromHash(HASH_USER32);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] U32_DLL Get Fail.\n[+] Try Load U32_DLL.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> User32_dll[] = &#123; <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_User32 = pLoadLibraryA(User32_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] U32_DLL Load Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwsprintfA = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_User32, Hash_wsprintfA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HMODULE hModule_NtDll = Yes_GetModuleHandle_FromHash(HASH_NTDLL);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] U32_DLL Get Fail.\n[+] Try Load U32_DLL.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> NtDll_dll[] = &#123; <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_NtDll = pLoadLibraryA(NtDll_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] U32_DLL Load Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pRtlAllocateHeap = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_NtDll, Hash_RtlAllocateHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了预期需求。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">api_init();</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pLLA Func Addr: 0x%p \n&quot;</span>, pLoadLibraryA);</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pRAH Func Addr: 0x%p \n&quot;</span>, pRtlAllocateHeap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数调用 api_init 对自定义 API 进行初始化，然后使用 PRINTA 宏打印信息。</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025163259037.png" class=""><p>整个项目仅需包含 <code>Windows.h</code> 头文件，来到 Pe-Bear 可以看到，Kernel32.dll 的导入表中的敏感函数导入信息已经去掉，同样加载的 User32.dll 和 NTDLL.dll 也没有显示。</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025163633851.png" class=""><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>api.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>* __cdecl <span class="title function_">memset</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, <span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> intrinsic(memset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> function(memset)</span></span><br><span class="line"><span class="type">void</span>* __cdecl <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* Destination, <span class="type">int</span> Value, <span class="type">size_t</span> Size)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)Destination;</span><br><span class="line">    <span class="keyword">while</span> (Size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *p = (<span class="type">unsigned</span> <span class="type">char</span>)Value;</span><br><span class="line">        p++;</span><br><span class="line">        Size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Destination;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PVOID PAPI_SET_NAMESPACE;</span><br><span class="line"><span class="keyword">typedef</span> PVOID PACTIVATION_CONTEXT;</span><br><span class="line"><span class="keyword">typedef</span> PVOID PRTL_USER_PROCESS_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR  Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    WORD LoadCount;</span><br><span class="line">    WORD TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG TimeDateStamp;</span><br><span class="line">        PVOID LoadedImports;</span><br><span class="line">    &#125;;</span><br><span class="line">    PACTIVATION_CONTEXT EntryPointActivationContext;</span><br><span class="line">    PVOID PatchInformation;</span><br><span class="line">    LIST_ENTRY ForwarderLinks;</span><br><span class="line">    LIST_ENTRY ServiceTagLinks;</span><br><span class="line">    LIST_ENTRY StaticLinks;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span> &#123;</span></span><br><span class="line">    ULONG                   Length;</span><br><span class="line">    ULONG                   Initialized;</span><br><span class="line">    PVOID                   SsHandle;</span><br><span class="line">    LIST_ENTRY              InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY              InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY              InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    BOOLEAN InheritedAddressSpace;</span><br><span class="line">    BOOLEAN ReadImageFileExecOptions;</span><br><span class="line">    BOOLEAN BeingDebugged;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        BOOLEAN BitField;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            BOOLEAN ImageUsesLargePages : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsImageDynamicallyRelocated : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN SkipPatchingUser32Forwarders : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsPackagedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsAppContainer : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcessLight : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsLongPathAwareProcess : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    HANDLE Mutant;</span><br><span class="line">    PVOID ImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    PVOID SubSystemData;</span><br><span class="line">    PVOID ProcessHeap;</span><br><span class="line">    PRTL_CRITICAL_SECTION FastPebLock;</span><br><span class="line">    PSLIST_HEADER AtlThunkSListPtr;</span><br><span class="line">    PVOID IFEOKey;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ProcessInJob : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessInitializing : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVEH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVCH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingFTH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessPreviouslyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessCurrentlyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessImagesHotPatched : <span class="number">1</span>; <span class="comment">// REDSTONE5</span></span><br><span class="line">            ULONG ReservedBits0 : <span class="number">24</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID KernelCallbackTable;</span><br><span class="line">        PVOID UserSharedInfoPtr;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SystemReserved;</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    PAPI_SET_NAMESPACE ApiSetMap;</span><br><span class="line">    ULONG TlsExpansionCounter;</span><br><span class="line">    PVOID TlsBitmap;</span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    PVOID ReadOnlySharedMemoryBase;</span><br><span class="line">    PVOID SharedData;                   <span class="comment">// HotpatchInformation</span></span><br><span class="line">    PVOID* ReadOnlyStaticServerData;</span><br><span class="line">    PVOID AnsiCodePageData;             <span class="comment">// PCPTABLEINFO</span></span><br><span class="line">    PVOID OemCodePageData;              <span class="comment">// PCPTABLEINFO</span></span><br><span class="line">    PVOID UnicodeCaseTableData;         <span class="comment">// PNLSTABLEINFO</span></span><br><span class="line">    ULONG NumberOfProcessors;</span><br><span class="line">    ULONG NtGlobalFlag;</span><br><span class="line">    ULARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    SIZE_T HeapSegmentReserve;</span><br><span class="line">    SIZE_T HeapSegmentCommit;</span><br><span class="line">    SIZE_T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    SIZE_T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    ULONG NumberOfHeaps;</span><br><span class="line">    ULONG MaximumNumberOfHeaps;</span><br><span class="line">    PVOID* ProcessHeaps;                <span class="comment">// PHEAP</span></span><br><span class="line">    PVOID GdiSharedHandleTable;</span><br><span class="line">    PVOID ProcessStarterHelper;</span><br><span class="line">    ULONG GdiDCAttributeList;</span><br><span class="line">    PRTL_CRITICAL_SECTION LoaderLock;</span><br><span class="line">    ULONG OSMajorVersion;</span><br><span class="line">    ULONG OSMinorVersion;</span><br><span class="line">    USHORT OSBuildNumber;</span><br><span class="line">    USHORT OSCSDVersion;</span><br><span class="line">    ULONG OSPlatformId;</span><br><span class="line">    ULONG ImageSubsystem;</span><br><span class="line">    ULONG ImageSubsystemMajorVersion;</span><br><span class="line">    ULONG ImageSubsystemMinorVersion;</span><br><span class="line">    KAFFINITY ActiveProcessAffinityMask;</span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">60</span>];</span><br><span class="line">    PVOID PostProcessInitRoutine;</span><br><span class="line">    PVOID TlsExpansionBitmap;</span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    PVOID pShimData;</span><br><span class="line">    PVOID AppCompatInfo;                        <span class="comment">// APPCOMPAT_EXE_DATA</span></span><br><span class="line">    UNICODE_STRING CSDVersion;</span><br><span class="line">    PVOID ActivationContextData;                <span class="comment">// ACTIVATION_CONTEXT_DATA</span></span><br><span class="line">    PVOID ProcessAssemblyStorageMap;            <span class="comment">// ASSEMBLY_STORAGE_MAP</span></span><br><span class="line">    PVOID SystemDefaultActivationContextData;   <span class="comment">// ACTIVATION_CONTEXT_DATA</span></span><br><span class="line">    PVOID SystemAssemblyStorageMap;             <span class="comment">// ASSEMBLY_STORAGE_MAP</span></span><br><span class="line">    SIZE_T MinimumStackCommit;</span><br><span class="line">    PVOID SparePointers[<span class="number">2</span>];                     <span class="comment">// 19H1 (previously FlsCallback to FlsHighIndex)</span></span><br><span class="line">    PVOID PatchLoaderData;</span><br><span class="line">    PVOID ChpeV2ProcessInfo;                    <span class="comment">// _CHPEV2_PROCESS_INFO</span></span><br><span class="line">    ULONG AppModelFeatureState;</span><br><span class="line">    ULONG SpareUlongs[<span class="number">2</span>];</span><br><span class="line">    USHORT ActiveCodePage;</span><br><span class="line">    USHORT OemCodePage;</span><br><span class="line">    USHORT UseCaseMapping;</span><br><span class="line">    USHORT UnusedNlsField;</span><br><span class="line">    PVOID WerRegistrationData;</span><br><span class="line">    PVOID WerShipAssertPtr;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID pContextData; <span class="comment">// WIN7</span></span><br><span class="line">        PVOID pUnused; <span class="comment">// WIN10</span></span><br><span class="line">        PVOID EcCodeBitMap; <span class="comment">// WIN11</span></span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID pImageHeaderHash;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG TracingFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG CritSecTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG LibLoaderTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG SpareTracingBits : <span class="number">29</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONGLONG CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">    PRTL_CRITICAL_SECTION TppWorkerpListLock;</span><br><span class="line">    LIST_ENTRY TppWorkerpList;</span><br><span class="line">    PVOID WaitOnAddressHashTable[<span class="number">128</span>];</span><br><span class="line">    PVOID TelemetryCoverageHeader;              <span class="comment">// REDSTONE3</span></span><br><span class="line">    ULONG CloudFileFlags;</span><br><span class="line">    ULONG CloudFileDiagFlags;                   <span class="comment">// REDSTONE4</span></span><br><span class="line">    CHAR PlaceholderCompatibilityMode;</span><br><span class="line">    CHAR PlaceholderCompatibilityModeReserved[<span class="number">7</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LEAP_SECOND_DATA</span>* <span class="title">LeapSecondData</span>;</span>   <span class="comment">// REDSTONE5</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG LeapSecondFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG SixtySecondEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG Reserved : <span class="number">31</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG NtGlobalFlag2;</span><br><span class="line">    ULONGLONG ExtendedFeatureDisableMask; <span class="comment">// since WIN11</span></span><br><span class="line">&#125; PEB, * PPEB;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))</span></span><br><span class="line">UINT32 <span class="title function_">HashStringJenkinsOneAtATime32BitA</span><span class="params">(IN PCHAR String)</span> &#123;</span><br><span class="line">    SIZE_T Index = <span class="number">0</span>;</span><br><span class="line">    UINT32 Hash = <span class="number">0</span>;</span><br><span class="line">    SIZE_T Length = <span class="built_in">strlen</span>(String);</span><br><span class="line">    <span class="keyword">while</span> (Index != Length) &#123;</span><br><span class="line">        Hash += String[Index++];</span><br><span class="line">        Hash += Hash &lt;&lt; <span class="number">7</span>; <span class="comment">// seed</span></span><br><span class="line">        Hash ^= Hash &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Hash += Hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    Hash ^= Hash &gt;&gt; <span class="number">11</span>;</span><br><span class="line">    Hash += Hash &lt;&lt; <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">return</span> Hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_MAX_PATH256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TO_UPPER(C) C &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; C &lt;= <span class="string">&#x27;z&#x27;</span> ? C + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span> : C</span></span><br><span class="line">HMODULE <span class="title function_">Yes_GetModuleHandle_FromHash</span><span class="params">(IN UINT32 ui32DllHash)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64<span class="comment">// 获取 x64 peb</span></span></span><br><span class="line">    PPEB            pPeb = (PEB*)(__readgsqword(<span class="number">0x60</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32<span class="comment">// 获取 x86 peb</span></span></span><br><span class="line">    PPEB            pPeb = (PEB*)(__readfsdword(<span class="number">0x30</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);<span class="comment">// 获取 Ldr</span></span><br><span class="line">    PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line">    <span class="keyword">while</span> (pDte-&gt;FullDllName.Length != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        CHAR UpperCaseDllName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pDte-&gt;FullDllName.Length; i++)<span class="comment">// 转化成大写</span></span><br><span class="line">            UpperCaseDllName[i] = (CHAR)TO_UPPER(pDte-&gt;FullDllName.Buffer[i]);</span><br><span class="line">        <span class="keyword">if</span> (ui32DllHash == HASHA(UpperCaseDllName))<span class="comment">// 判断 Hash 是否一致</span></span><br><span class="line">            <span class="keyword">return</span> pDte-&gt;InInitializationOrderLinks.Flink;<span class="comment">// 返回 DLL Base Address</span></span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);<span class="comment">// 链表下一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress_FromHash</span><span class="params">(IN HMODULE hModule, IN UINT32 ui32FuncHash)</span> &#123;</span><br><span class="line">    PBYTE pBase = (PBYTE)hModule;<span class="comment">// 转化一下</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;<span class="comment">// 获取 DOS 头</span></span><br><span class="line">    <span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);<span class="comment">// 获取 NT 头</span></span><br><span class="line">    <span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;<span class="comment">// 获取可选头</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<span class="comment">// 获取导出目录</span></span><br><span class="line">    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);<span class="comment">// 获取函数名称数组指针</span></span><br><span class="line">    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);<span class="comment">// 获取函数地址数组指针</span></span><br><span class="line">    PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);<span class="comment">// 获取函数序号数组指针</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++)</span><br><span class="line">        <span class="keyword">if</span> (HASHA(pBase + FunctionNameArray[i]) == ui32FuncHash)<span class="comment">// 比较函数名的 Hash</span></span><br><span class="line">            <span class="keyword">return</span> (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);<span class="comment">// 通过函数序数值获取函数地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTA( STR, ... )\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (1) &#123;\</span></span><br><span class="line"><span class="meta">        LPSTR buf = (LPSTR)pRtlAllocateHeap(pGetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ( buf != NULL ) &#123;\</span></span><br><span class="line"><span class="meta">            int len = pwsprintfA( buf, STR, __VA_ARGS__ );\</span></span><br><span class="line"><span class="meta">            pWriteConsoleA( pGetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );\</span></span><br><span class="line"><span class="meta">            pHeapFree( pGetProcessHeap(), 0, buf );\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line">UINT32 <span class="title function_">HashStringJenkinsOneAtATime32BitA</span><span class="params">(IN PCHAR String)</span>;</span><br><span class="line">HMODULE <span class="title function_">Yes_GetModuleHandle_FromHash</span><span class="params">(IN UINT32 ui32DllHash)</span>;</span><br><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress_FromHash</span><span class="params">(IN HMODULE hModule, IN UINT32 ui32FuncHash)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NTDLL              0x4898F593</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_USER32             0x81E3778E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_KERNEL32           0x367DC15A</span></span><br><span class="line"><span class="comment">// WIN API Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_LoadLibraryA       0x19F0EEAF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_wsprintfA          0x2AF0CBF4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapFree           0x1154459B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapAlloc          0x2F9B708A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_RtlAllocateHeap    0xF5613878</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetStdHandle       0x0C685B0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_WriteConsoleA      0x65304EA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetProcessHeap     0x3BCCFAC6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span><span class="params">(WINAPI* fnLoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnHeapFree)</span><span class="params">(HANDLE hHeap, DWORD dwFlags, _Frees_ptr_opt_ LPVOID lpMem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* fnHeapAlloc)</span><span class="params">(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlallocateheap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* fnRtlAllocateHeap)</span><span class="params">(PVOID HeapHandle, ULONG Flags, SIZE_T Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-getprocessheap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/console/getstdhandle</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetStdHandle)</span><span class="params">(DWORD nStdHandle)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/console/writeconsole</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnWriteConsoleA)</span><span class="params">(HANDLE  hConsoleOutput, <span class="type">const</span> VOID* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID  lpReserved)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-getprocessheap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-wsprintfw</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(WINAPIV* fnwsprintfA)</span><span class="params">(LPSTR unnamedParam1, LPCSTR unnamedParam2, ...)</span>;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_NUM 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC_NUM 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showHash</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">char</span>* dllList[DLL_NUM] = &#123;</span><br><span class="line"><span class="string">&quot;NTDLL.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;USER32.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;KERNEL32.DLL&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span>* funcList[FUNC_NUM] = &#123;</span><br><span class="line"><span class="string">&quot;LoadLibraryA&quot;</span>,</span><br><span class="line"><span class="string">&quot;wsprintfA&quot;</span>,</span><br><span class="line"><span class="string">&quot;HeapFree&quot;</span>,</span><br><span class="line"><span class="string">&quot;HeapAlloc&quot;</span>,</span><br><span class="line"><span class="string">&quot;RtlAllocateHeap&quot;</span>,</span><br><span class="line"><span class="string">&quot;GetStdHandle&quot;</span>,</span><br><span class="line"><span class="string">&quot;WriteConsoleA&quot;</span>,</span><br><span class="line"><span class="string">&quot;GetProcessHeap&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span>* funcSysList[] = &#123;</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// DLL Name Hash\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DLL_NUM; i++) &#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define HASH_&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; dllList[i][j] != <span class="string">&#x27;.&#x27;</span>; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dllList[i][j]);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t0x%0.8X \n&quot;</span>, HASHA(dllList[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// WIN API Name Hash\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FUNC_NUM; i++) &#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define Hash_%s&quot;</span>, funcList[i]);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; funcList[i][j] != <span class="string">&#x27;\x00&#x27;</span>; j++);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">24</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%0.8X \n&quot;</span>, HASHA(funcList[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule_Kernel32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_Kernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] K32_DLL Get Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n[+] Get DLL KERNEL32\t: 0x%p \n+------------------------------------------+\n&quot;</span>, hModule_Kernel32);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] LLA func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] HFr func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapFree));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] HAl func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapAlloc));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] GSH func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetStdHandle));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] WCA func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_WriteConsoleA));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] GPH func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetProcessHeap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE hModule_User32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] U32_DLL Get Fail.\n[+] Try Load U32_DLL.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> User32_dll[] = &#123; <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_User32 = (fnLoadLibraryA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA)(User32_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] U32_DLL Load Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n[+] Load DLL USER32\t: 0x%p \n+------------------------------------------+\n&quot;</span>, hModule_User32);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n[+] Get DLL USER32\t: 0x%p \n+------------------------------------------+\n&quot;</span>, hModule_User32);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] wpf func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_User32, Hash_wsprintfA));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+------------------------------------------+\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">fnLoadLibraryA pLoadLibraryA;</span><br><span class="line">fnHeapFree pHeapFree;</span><br><span class="line">fnHeapAlloc pHeapAlloc;</span><br><span class="line">fnGetStdHandle pGetStdHandle;</span><br><span class="line">fnWriteConsoleA pWriteConsoleA;</span><br><span class="line">fnGetProcessHeap pGetProcessHeap;</span><br><span class="line">fnwsprintfA pwsprintfA;</span><br><span class="line">fnRtlAllocateHeap pRtlAllocateHeap;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">api_init</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule_Kernel32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_Kernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pLoadLibraryA = (fnLoadLibraryA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA);</span><br><span class="line">pHeapFree = (fnHeapFree)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapFree);</span><br><span class="line">pHeapAlloc = (fnHeapAlloc)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapAlloc);</span><br><span class="line">pGetStdHandle = (fnGetStdHandle)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetStdHandle);</span><br><span class="line">pWriteConsoleA = (fnWriteConsoleA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_WriteConsoleA);</span><br><span class="line">pGetProcessHeap = (fnGetProcessHeap)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetProcessHeap);</span><br><span class="line"></span><br><span class="line">HMODULE hModule_User32 = Yes_GetModuleHandle_FromHash(HASH_USER32);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">char</span> User32_dll[] = &#123; <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_User32 = pLoadLibraryA(User32_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwsprintfA = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_User32, Hash_wsprintfA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HMODULE hModule_NtDll = Yes_GetModuleHandle_FromHash(HASH_NTDLL);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">char</span> NtDll_dll[] = &#123; <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_NtDll = pLoadLibraryA(NtDll_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pRtlAllocateHeap = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_NtDll, Hash_RtlAllocateHeap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">showHash();</span><br><span class="line">test();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">api_init();</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pLLA Func Addr: 0x%p \n&quot;</span>, pLoadLibraryA);</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pRAH Func Addr: 0x%p \n&quot;</span>, pRtlAllocateHeap);</span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good Luck.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Maldev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Maldev - 反分析、反沙箱</title>
      <link href="/2024/10/23/Windows%20Maldev%20-%20%E5%8F%8D%E5%88%86%E6%9E%90%E3%80%81%E5%8F%8D%E6%B2%99%E7%AE%B1/"/>
      <url>/2024/10/23/Windows%20Maldev%20-%20%E5%8F%8D%E5%88%86%E6%9E%90%E3%80%81%E5%8F%8D%E6%B2%99%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Maldev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 恶意软件开发</title>
      <link href="/2024/10/08/Windows%20%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2024/10/08/Windows%20%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows 下的恶意软件一般包含以下功能</p><ul><li><input disabled="" type="checkbox"> Payload 存储、加密、混淆、执行</li><li><input disabled="" type="checkbox"> PE 信息伪造、进程信息伪造</li><li><input disabled="" type="checkbox"> 沙箱检测、虚拟环境检测</li><li><input disabled="" type="checkbox"> 反调试、杀软绕过</li><li><input disabled="" type="checkbox"> EDR 绕过</li></ul><h2 id="Payload-存储"><a href="#Payload-存储" class="headerlink" title="Payload 存储"></a>Payload 存储</h2><p>目前有以下存储方式</p><ul><li>PE 文件内部<ul><li>.data .rdata 段</li><li>.text 段</li><li>.rsrc 段</li></ul></li><li>本地 Payload 分离<ul><li>可以起一个伪装的名称，config.xml、resources.pak…</li></ul></li><li>远程 Payload<ul><li><a href="https://xxx.com/favicon.ico">https://xxx.com/favicon.ico</a></li><li><a href="http://xxx.com/uploads/images/head.png">http://xxx.com/uploads/images/head.png</a></li></ul></li><li>Windows 注册表</li></ul><p>三种方法各有优劣，应根据实际应用场景进行选择。例如：</p><ul><li>在权限维持场景中，可以优先考虑 Payload 分离；</li><li>在社工钓鱼的场景中，可以优先考虑远程文件的方式，这样可以在钓鱼行动被发现后更改远程 Payload 内容；</li><li>在多层内网环境或者存在离线环境的情况下，就优先考虑在 PE 文件内部存储 Payload，这样会让蓝队不那么容易去追踪感染链。</li></ul><h3 id="PE-文件内部存储"><a href="#PE-文件内部存储" class="headerlink" title="PE 文件内部存储"></a>PE 文件内部存储</h3><ul><li><input disabled="" type="checkbox"> .data 段主要包含初始化的全局和静态变量，可读可写；.rdata 段存放常量，只读。一个较小的程序需要初始化一个较大的变量，这种行为看起来多少会有些奇怪。</li><li><input disabled="" type="checkbox"> .text 段具有可执行权限，存储在其中的数据可以直接执行，因此这个段需要接受的审查会更严格，如果 Payload 较小（小于 10 字节），那么放在此段效果会很好。</li><li><input checked="" disabled="" type="checkbox"> .rsrc 段主要放置资源文件，实际情况下大部分的二进制文件都会在此存放数据，所以 Payload 可以未造成图标或者其他文件存储在这里。</li></ul><h3 id="Payload-分离"><a href="#Payload-分离" class="headerlink" title="Payload 分离"></a>Payload 分离</h3><p>Payload 分离，需要考虑的问题就是如何伪装，可以根据普通应用程序的内容来模仿。</p><ul><li>Windows 注册表</li><li>游戏资源文件</li><li>主题文件</li><li>chm 手册</li><li>pak、v8 文件（主要是一些基于浏览器打包的应用程序）</li><li>ui 文件</li><li>dll 文件</li></ul><h3 id="远程-Payload"><a href="#远程-Payload" class="headerlink" title="远程 Payload"></a>远程 Payload</h3><p>本质上也是对 Payload 进行分离，所以需要考虑的内容也是如何伪装</p><ul><li>图标资源</li><li>API 请求</li><li>…</li></ul><h2 id="Payload-加密"><a href="#Payload-加密" class="headerlink" title="Payload 加密"></a>Payload 加密</h2><ul><li><input disabled="" type="checkbox"> XOR</li><li><input disabled="" type="checkbox"> RC4</li><li><input checked="" disabled="" type="checkbox"> AES</li></ul><p>XOR、RC4 加密已经无法绕过 Windows Defender 了，建议使用 AES 或者其他强加密方法。</p><h2 id="Payload-混淆"><a href="#Payload-混淆" class="headerlink" title="Payload 混淆"></a>Payload 混淆</h2><ul><li><input checked="" disabled="" type="checkbox"> IPv4&#x2F;IPv6</li><li><input checked="" disabled="" type="checkbox"> MAC</li><li><input checked="" disabled="" type="checkbox"> UUID</li></ul><p>三种方法可以结合应用场景进行选择。例如：Payload 分离的存储方式可以搭配 MAC 混淆，将 Payload 存储在 xml 等文件中。</p><h2 id="Payload-执行"><a href="#Payload-执行" class="headerlink" title="Payload 执行"></a>Payload 执行</h2><ul><li><input disabled="" type="checkbox"> 本地&#x2F;远程 DLL 加载</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程进程执行</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程线程创建</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程线程劫持</li><li><input disabled="" type="checkbox"> APC 注入</li><li><input disabled="" type="checkbox"> 回调代码执行</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程映射注入</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程函数篡改</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Windows </tag>
            
            <tag> C </tag>
            
            <tag> 恶意软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog 解决方案</title>
      <link href="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前的解决方案：Hexo &amp; cactus + Github Action</p></blockquote><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>Blog 采用 Hexo 引擎 cactus 主题，并对主题做了些微改动</p><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><blockquote><p>我这里使用的是 Node.js 18.x 版本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"><span class="comment"># 创建私有 github 仓库 https://github.com/[youname]/blog.git</span></span><br><span class="line"><span class="comment"># 想知道如何 clone/push/pull 私有仓库，去网上搜搜吧</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/[your_name]/blog.git</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 初始化 blog</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/probberechts/hexo-theme-cactus.git themes/cactus</span><br></pre></td></tr></table></figure><ul><li>编辑 blog&#x2F;_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&#x27;标题&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;站点简介&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&#x27;作者名称&#x27;</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"># 我这里使用的是 github pages 的一个子目录</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">&#x27;https://[your_name].github.io/&#x27;</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">cactus</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 其他可以保持默认</span></span><br></pre></td></tr></table></figure><ul><li>编辑 <code>blog/theme/cactus/_config.yml</code>，配置内容参考作者提供的文档即可</li></ul><blockquote><p><a href="https://github.com/probberechts/hexo-theme-cactus">https://github.com/probberechts/hexo-theme-cactus</a></p></blockquote><h3 id="Github-Action-自动化发布"><a href="#Github-Action-自动化发布" class="headerlink" title="Github Action 自动化发布"></a>Github Action 自动化发布</h3><ul><li>编辑 .github&#x2F;workflows&#x2F;hexo.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">hexo-ci</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permissions:</span></span><br><span class="line">  <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">使用</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">          </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装搜索</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-search</span> <span class="string">--save</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">markdown</span> <span class="string">图片索引</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-image-link</span> <span class="string">--save</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">发布到公共仓库</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLISH_BLOG</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">          <span class="attr">destination_dir:</span> <span class="string">blog</span></span><br><span class="line">          <span class="attr">external_repository:</span> [<span class="string">your_name</span>]<span class="string">/[your_name].github.io</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>我这里是跨仓库发布，因此需要一个 TOKEN，上面我命名的这个 <code>secrets.PUBLISH_BLOG</code></p><p>登录 Github 之后，打开 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 页面</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929150803.png" class=""><ol><li>这里的 Note 可以随便设置，是用于区分 token 的，以便于看到后可以快速回忆起，建议设置成仓库名：Blog_token</li><li>Expiration 是可以时间，我嫌麻烦一般设置成永久，安全起见可以设置成 90 天，然后过期再更新</li><li>下面的作用范围只需要勾选 workflow 就行，会自动选中 repo 权限</li></ol><p>生成后会得到一个密钥，先复制下来待会要用</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151040.png" class=""><p>打开 <a href="https://github.com/fermionorz/blog/settings/secrets/actions/new">https://github.com/fermionorz/blog/settings/secrets/actions/new</a> 页面，添加刚刚复制的密钥</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151247.png" class=""><p>添加成功后的效果</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151323.png" class=""><p>这里就没问题了，这个时候每次对仓库进行提交，都会自动把内容发布到 <code>[your_name]/[your_name].github.io</code> 仓库的 <code>blog</code> 目录中</p><p>然后可以转到 <code>[your_name].github.io</code> 仓库看到了</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151818.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> Site </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
