<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>家用存储解决方案</title>
      <link href="/2024/11/01/%E5%AE%B6%E7%94%A8%E5%AD%98%E5%82%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/11/01/%E5%AE%B6%E7%94%A8%E5%AD%98%E5%82%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><table><thead><tr><th>类别</th><th>选择</th></tr></thead><tbody><tr><td>硬件</td><td>群晖 423+</td></tr><tr><td>系统</td><td>群晖 DSM</td></tr><tr><td>存储方案</td><td>Johnny.Decimal</td></tr></tbody></table><h2 id="Johnny-Decimal-分类法存储"><a href="#Johnny-Decimal-分类法存储" class="headerlink" title="Johnny.Decimal 分类法存储"></a>Johnny.Decimal 分类法存储</h2><blockquote><p><a href="https://johnnydecimal.com/">https://johnnydecimal.com/</a></p></blockquote><ul><li><p>00-09 Personal</p><ul><li>00 Information<ul><li>00.00 简历1</li><li>00.01 简历2</li><li>00.10 身份证</li><li>00.20 头像</li><li>00.31 证书1</li><li>00.32 证书2</li><li>壁纸</li><li>Offer</li></ul></li><li>01 Blog</li><li>09 ProgramData<ul><li>09.01 QQ</li><li>09.02 微信</li><li>…</li></ul></li></ul></li><li><p>10-19 Work</p><ul><li>10 其他工作</li><li>11 第一个公司</li><li>12 第二个公司</li></ul></li><li><p>20-29 Wiki</p><ul><li>20 …</li><li>21 Operation</li><li>22 Security</li><li>23 Hardware</li><li>24 Coding</li><li>25 Game</li><li>…</li></ul></li><li><p>30-39 Document</p><ul><li>31 Operation</li><li>32 Security</li><li>33 Hardware</li><li>34 Coding</li><li>35 Game</li><li>…</li></ul></li><li><p>40-49 Media</p><ul><li>41 Music<ul><li>41.01 周杰伦</li><li>…</li></ul></li><li>…</li></ul></li><li><p>50-59 PRepo</p><ul><li>51 C-Family</li><li>52 Rust</li><li>53 Python</li><li>…</li></ul></li><li><p>60-69 Books</p><ul><li>61 Operation</li><li>62 Security</li><li>…</li></ul></li><li><p>70-79 Downloads</p><ul><li>71 Browser</li><li>72 BaiduCloudDisk</li><li>73 QQ</li><li>…</li></ul></li><li><p>80-89 Resources</p><ul><li>85 WPrograms<ul><li>85.00 WinGet_List.txt</li><li>85.01 Hashcat</li></ul></li><li>89 Virtual Machines<ul><li>89.01 Test Windows 11 </li><li>89.02 Coding Ubuntu 24.04.01</li><li>…</li><li>89.98 导出的虚拟机</li><li>89.99 操作系统镜像</li></ul></li></ul></li><li><p>90-99 Archive</p><ul><li>90 实时同步数据<ul><li>00-09 Personal</li><li>20-29 Wiki</li></ul></li><li>91</li><li>…</li><li>99 冷备数据<ul><li>20241030 微信聊天记录.7z</li><li>20241030 QQ-聊天记录.7z</li><li>2022-2023 第一家公司.7z</li><li>…</li></ul></li></ul></li></ul><h3 id="分类说明"><a href="#分类说明" class="headerlink" title="分类说明"></a>分类说明</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>00 Information</td><td>低频变化的常用信息</td></tr><tr><td>11 第一个公司</td><td>公司有关文件不论类型一律放在此处</td></tr><tr><td>20-29 Wiki</td><td>可以根据个人喜好，建立 Wiki 文档</td></tr><tr><td>30-39 Document</td><td>内部分类可以与 Wiki 一致，存放整理好的文档</td></tr><tr><td>…</td><td>…</td></tr><tr><td>50-59 PRepo</td><td>各语言代码仓库</td></tr><tr><td>60-69 Books</td><td>存放 PDF 等格式电子书，二级类别可以与 Wiki 一致</td></tr><tr><td>70-79 Downloads</td><td>存放各渠道下载文件</td></tr><tr><td>80-89 Resources</td><td>各类资源文件</td></tr><tr><td>90-99 Archive</td><td>存放归档好的文件，给定期备份操作做准备</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC Linux 解决方案</title>
      <link href="/2024/10/29/PC%20Linux%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/10/29/PC%20Linux%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><table><thead><tr><th>类别</th><th>选项</th></tr></thead><tbody><tr><td>发行版</td><td>Arch Linux</td></tr><tr><td>字体</td><td>JetBrains Mono</td></tr><tr><td>桌面环境</td><td>i3-wm</td></tr><tr><td>锁屏</td><td>i3lock</td></tr><tr><td>状态栏</td><td>i3blocks、i3status</td></tr><tr><td>终端模拟器</td><td>alacritty、kitty</td></tr><tr><td>软件启动器</td><td>rofi、wofi</td></tr><tr><td>Web 浏览器</td><td>Firefox、Minbrowser</td></tr><tr><td>媒体播放器</td><td>VLC、mpv</td></tr><tr><td>媒体编辑器</td><td>Blender、GIMP、Inkscape、Audacity、ImageMagick</td></tr><tr><td>安全软件</td><td>VeraCrypt、Bitwarden、</td></tr></tbody></table><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>加载镜像后运行 <code>archinstall</code> 无脑安装即可。建议安装时顺带添加的软件包:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neovim tmux git bash-completion openssl-1.1 </span><br></pre></td></tr></table></figure><p>启动后更新系统 <code>sudo pacman -Syyu</code>，然后安装 aur 包管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S base-devel proxychains-ng gnu-free-fonts ttf-jetbrains-mono ttf-jetbrains-mono-nerd</span><br><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/paru.git</span><br><span class="line"><span class="built_in">cd</span> paru</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><h3 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h3><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><ul><li>安装 i3、xorg、alacritty、rofi、firefox</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S xorg xorg-xinit i3 feh alacritty rofi firefox firefox-developer-edition-i18n-zh-cn noto-fonts noto-fonts-cjk  noto-fonts-emoji  noto-fonts-extra</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Maldev - ITA 隐藏与混淆</title>
      <link href="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/"/>
      <url>/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ITA(Import Table Address) 包含有关 PE 文件的信息，例如使用的函数名以及 DLL，此类信息常用于对二进制文件进行标记和检测。例如：</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241024083658530.png" class=""><p>可以看到，这个 PE 文件导入了 <code>CreateRemoteThread</code>、<code>OpenProcess</code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code> 等函数，Shellcode 加载流程尽收眼底。</p><p>想要隐藏这些内容，可以使用 <code>GetProcAddress</code>、<code>GetModuleHandle</code> 或 <code>LoadLibrary</code> 在运行时动态加载这些函数。</p><p>但这又会出现其他问题。</p><ul><li>动态导入的函数相关字符串会出现在 PE 文件中，这个可以用于签名检测</li><li><code>GetProcAddress</code> 和 <code>GetModuleHandle</code> 函数的导入信息也会出现在 ITA 中</li></ul><p>想隐藏字符串，那只能通过替换，可以通过字符串加密、Hash 运算等方法；对于 <code>GetProcAddress</code> 和 <code>GetModuleHandle</code> 函数的信息，可以通过自实现来隐藏。两者结合。</p><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>Hash 函数的选择，最好是能够轻量实现，并且分布均匀（以防冲突），这里的 Demo 选用 <code>JenkinsOneAtATime32Bit</code> 算法，实现来自 <a href="https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringJenkinsOneAtATime32Bit.cpp">VX-API GitHub 仓库</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))</span></span><br><span class="line">UINT32 <span class="title function_">HashStringJenkinsOneAtATime32BitA</span><span class="params">(_In_ PCHAR String)</span></span><br><span class="line">&#123;</span><br><span class="line">SIZE_T Index = <span class="number">0</span>;</span><br><span class="line">UINT32 Hash = <span class="number">0</span>;</span><br><span class="line">SIZE_T Length = <span class="built_in">strlen</span>(String);</span><br><span class="line"><span class="keyword">while</span> (Index != Length)</span><br><span class="line">&#123;</span><br><span class="line">Hash += String[Index++];</span><br><span class="line">Hash += Hash &lt;&lt; <span class="number">7</span>; <span class="comment">// 这里的种子可以更改</span></span><br><span class="line">Hash ^= Hash &gt;&gt; <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">Hash += Hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">Hash ^= Hash &gt;&gt; <span class="number">11</span>;</span><br><span class="line">Hash += Hash &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="keyword">return</span> Hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了灵活和方便使用，设置了 <code>HASHA</code> 宏。</p><h2 id="实现-GetModuleHandle"><a href="#实现-GetModuleHandle" class="headerlink" title="实现 GetModuleHandle"></a>实现 GetModuleHandle</h2><p><code>GetModuleHandle</code> 函数用于在内存中检索指定 DLL 的句柄。函数返回 DLL 的句柄 (<code>HMODULE</code>) 或 <code>NULL</code> 。</p><h3 id="GetModuleHandle-原理"><a href="#GetModuleHandle-原理" class="headerlink" title="GetModuleHandle 原理"></a>GetModuleHandle 原理</h3><p><code>HMODULE</code> 数据类型是加载的 DLL 的基地址，表示 DLL 在进程地址空间中的位置。因此，替换函数的目标是检索指定 DLL 的基地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">  BYTE                          Reserved1[<span class="number">2</span>];</span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line">  BYTE                          Reserved2[<span class="number">1</span>];</span><br><span class="line">  PVOID                         Reserved3[<span class="number">2</span>];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr; <span class="comment">// 该结构包含关于进程加载模块的信息。</span></span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  PVOID                         Reserved4[<span class="number">3</span>];</span><br><span class="line">  PVOID                         AtlThunkSListPtr;</span><br><span class="line">  PVOID                         Reserved5;</span><br><span class="line">  ULONG                         Reserved6;</span><br><span class="line">  PVOID                         Reserved7;</span><br><span class="line">  ULONG                         Reserved8;</span><br><span class="line">  ULONG                         AtlThunkSListPtr32;</span><br><span class="line">  PVOID                         Reserved9[<span class="number">45</span>];</span><br><span class="line">  BYTE                          Reserved10[<span class="number">96</span>];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved11[<span class="number">128</span>];</span><br><span class="line">  PVOID                         Reserved12[<span class="number">1</span>];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure><p>PEB 结构的 <code>PEB_LDR_DATA Ldr</code> 成员包含进程中加载的 DLL 的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB_LDR_DATA &#123;</span><br><span class="line">  BYTE       Reserved1[8];</span><br><span class="line">  PVOID      Reserved2[3];</span><br><span class="line">  LIST_ENTRY InMemoryOrderModuleList;  // 内存中模块列表</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure><p>对应 <code>LIST_ENTRY</code> 结构是一个双向链表，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025085631337.png" class=""><p>微软文档中说明，<code>_PEB_LDR_DATA</code> 的 InMemeoryOrderModuleList 成员包含进程加载模块的双向链表的头部。列表中的每个项都是指向 LDR_DATA_TABLE_ENTRY 结构的指针。并且给出了 <code>_LDR_DATA_TABLE_ENTRY</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    PVOID Reserved1[<span class="number">2</span>];</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    PVOID DllBase;     <span class="comment">// DLL 基地址</span></span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    UNICODE_STRING FullDllName;  <span class="comment">// 已加载 DLL 模块的文件名</span></span><br><span class="line">    BYTE Reserved4[<span class="number">8</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">3</span>];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CheckSum;</span><br><span class="line">        PVOID Reserved6;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>因此，需要关注的两个重点变量已经找到</p><ul><li>DLL 基地址: PEB -&gt; Ldr -&gt; InMemoryOrderModuleList -&gt; Flink -&gt; DllBase （这个其实不是）</li><li>DLL 文件名: PEB -&gt; Ldr -&gt; InMemoryOrderModuleList -&gt; Flink -&gt; FullDllName</li></ul><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HMODULE <span class="title function_">Yes_GetModuleHandle</span><span class="params">(IN LPCWSTR szModuleName)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 peb</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 <span class="comment">// 如果编译为 x64</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readgsqword(<span class="number">0x60</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32 <span class="comment">// 如果编译为 x32</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readfsdword(<span class="number">0x30</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 获取 Ldr</span></span><br><span class="line">PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);</span><br><span class="line"><span class="comment">// 获取链表中的第一个元素，其中包含第一个模块的信息 </span></span><br><span class="line">PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pDte-&gt;FullDllName.Length != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Found Dll %-15ls DLLBase: 0x%p Reserved2[0]: 0x%p \n&quot;</span>, pDte-&gt;FullDllName.Buffer, pDte-&gt;DllBase, pDte-&gt;Reserved2[<span class="number">0</span>]);</span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">GetModuleHandleH(<span class="string">&quot;&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025093521044.png" class=""><p>对比 Process Hacker 打开的进程信息</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025093502653.png" class=""><p>发现 <code>pDte-&gt;Reserved2[0]</code> 成员是需要的 DLL 基地址。</p><p>现在枚举 DLL 文件名，通过 Hash 校验来确定目标 DLL 基地址。可以实现对函数名进行 Hash 计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showHash</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">char</span> dllName;</span><br><span class="line"><span class="type">char</span>* dllList[DLL_NUM] = &#123;</span><br><span class="line"><span class="string">&quot;NTDLL.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;USER32.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;KERNEL32.DLL&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DLL_NUM; i++) &#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; dllList[i][j] != <span class="string">&#x27;.&#x27;</span>; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dllList[i][j]);</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">7</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t0x%0.8X \n&quot;</span>, HASHA(dllList[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025100804977.png" class=""><p>这样比较方便去定义，并且统一转换成大写。</p><p>接下来更新一下 <code>Yes_GetModuleHandle</code> 函数为 <code>Yes_GetModuleHandle_FromHash</code></p><p>这里大小写使用三元运算符实现，可以定义为一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_MAX_PATH256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TO_UPPER(C) C &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; C &lt;= <span class="string">&#x27;z&#x27;</span> ? C + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span> : C</span></span><br><span class="line">HMODULE <span class="title function_">GetModuleHandleH</span><span class="params">(IN UINT32 ui32DllHash)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64<span class="comment">// 获取 x64 peb</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readgsqword(<span class="number">0x60</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32<span class="comment">// 获取 x86 peb</span></span></span><br><span class="line">PPEB            pPeb = (PEB*)(__readfsdword(<span class="number">0x30</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);<span class="comment">// 获取 Ldr</span></span><br><span class="line">PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pDte-&gt;FullDllName.Length != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">CHAR UpperCaseDllName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pDte-&gt;FullDllName.Length; i++)<span class="comment">// 转化成大写</span></span><br><span class="line">UpperCaseDllName[i] = (CHAR)TO_UPPER(pDte-&gt;FullDllName.Buffer[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ui32DllHash == HASHA(UpperCaseDllName))<span class="comment">// 判断 Hash 是否一致</span></span><br><span class="line"><span class="keyword">return</span> pDte-&gt;Reserved2[<span class="number">0</span>];<span class="comment">// 返回 DLL Base Address</span></span><br><span class="line"></span><br><span class="line">pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);<span class="comment">// 链表下一节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下效果，没啥问题。</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025103841263.png" class=""><blockquote><p>上文的代码中关于 <code>GetModuleHandle</code> 的实现使用了 <code>winternl.h</code> 头文件，这里可以使用 <a href="https://www.nirsoft.net/">NirSoft</a> 与 <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpebteb.h">Process Hacker</a> 的结构体来代替。最终效果 仅需导入 <code>&lt;windows.h&gt;</code> 头文件。</p></blockquote><h2 id="实现-GetProcAddress"><a href="#实现-GetProcAddress" class="headerlink" title="实现 GetProcAddress"></a>实现 GetProcAddress</h2><p><code>GetProcAddress</code> 函数从 DLL 句柄中获取导出函数的地址。如果未找到函数名，返回 <code>NULL</code>。</p><h3 id="GetProcAddress-原理"><a href="#GetProcAddress-原理" class="headerlink" title="GetProcAddress 原理"></a>GetProcAddress 原理</h3><p>要访问导出的函数，需要访问 DLL 的导出表并在其中循环查找目标函数名称。</p><p>PE 头模块时提到，导出表是定义为 <code>IMAGE_EXPORT_DIRECTORY</code> 的结构。<a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#export-directory-table">微软文档</a></p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025110446188.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;   <span class="comment">// 导出地址表中的条目数量</span></span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">DWORD AddressOfFunctions;    <span class="comment">// 函数地址（相对于镜像基地址的 RVA）</span></span><br><span class="line">DWORD AddressOfNames;        <span class="comment">// 名称地址（相对于镜像基地址的 RVA）</span></span><br><span class="line">DWORD AddressOfNameOrdinals; <span class="comment">// 名称序号地址（相对于镜像基地址的 RVA）</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>需要关注的就是最后三个成员</p><ul><li><code>AddressOfFunctions</code> - 指定导出函数地址数组的地址。</li><li><code>AddressOfNames</code> - 指定导出函数名称地址数组的地址。</li><li><code>AddressOfNameOrdinals</code> - 指定导出函数的序号数组的地址。</li></ul><h3 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress</span><span class="params">(IN HMODULE hModule, IN LPCSTR lpApiName)</span> &#123;</span><br><span class="line">PBYTE pBase = (PBYTE)hModule;<span class="comment">// 转化一下</span></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;<span class="comment">// 获取 DOS 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);<span class="comment">// 获取 NT 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;<span class="comment">// 获取可选头</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<span class="comment">// 获取导出目录</span></span><br><span class="line"></span><br><span class="line">PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);<span class="comment">// 获取函数名称数组指针</span></span><br><span class="line">PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);<span class="comment">// 获取函数地址数组指针</span></span><br><span class="line">PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);<span class="comment">// 获取函数序号数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) &#123;</span><br><span class="line"></span><br><span class="line">CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);<span class="comment">// 获取函数的名称</span></span><br><span class="line">WORD wFunctionOrdinal = FunctionOrdinalArray[i];<span class="comment">// 获取函数的序号</span></span><br><span class="line">PVOID pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[wFunctionOrdinal]);<span class="comment">// 通过函数序数值获取函数地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[ No.%0.4d ] addr：0x%p Name：%s \n&quot;</span>, wFunctionOrdinal, pFunctionAddress, pFunctionName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025122811847.png" class=""><p>效果还可以，与 GetModuleHandle 一样，可以加入 Hash 校验，来确定目标函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress_FromHash</span><span class="params">(IN HMODULE hModule, IN UINT32 ui32FuncHash)</span> &#123;</span><br><span class="line">PBYTE pBase = (PBYTE)hModule;<span class="comment">// 转化一下</span></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;<span class="comment">// 获取 DOS 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);<span class="comment">// 获取 NT 头</span></span><br><span class="line"><span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;<span class="comment">// 获取可选头</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<span class="comment">// 获取导出目录</span></span><br><span class="line"></span><br><span class="line">PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);<span class="comment">// 获取函数名称数组指针</span></span><br><span class="line">PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);<span class="comment">// 获取函数地址数组指针</span></span><br><span class="line">PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);<span class="comment">// 获取函数序号数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++)</span><br><span class="line"><span class="keyword">if</span> (HASHA(pBase + FunctionNameArray[i]) == ui32FuncHash)<span class="comment">// 比较函数名的 Hash</span></span><br><span class="line"><span class="keyword">return</span> (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);<span class="comment">// 通过函数序数值获取函数地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Main 函数中调用检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL32        0xD4D19933</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LoadLibraryA                    0x000000000FA9B202</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] WinApi: 0x%p - HashApi: 0x%p Func: %s&quot;</span>, GetProcAddress(Yes_GetModuleHandle_FromHash(KERNEL32), <span class="string">&quot;LoadLibraryA&quot;</span>), Yes_GetProcAddress_FromHash(Yes_GetModuleHandle_FromHash(KERNEL32), LoadLibraryA), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025131445933.png" class=""><h2 id="动态加载-Win-Api"><a href="#动态加载-Win-Api" class="headerlink" title="动态加载 Win Api"></a>动态加载 Win Api</h2><p>目前已经实现了 GetModuleHandle 和 GetProcAddress，可以动态加载函数了，在加载之前，需要声明函数类型，以便在获取函数地址后进行强制转换。</p><p>Demo 计划实现一个代替 printf 函数的宏实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTA( STR, ... )        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (1) &#123;        \</span></span><br><span class="line"><span class="meta">        LPSTR buf = (LPSTR)pRtlAllocateHeap(pGetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ( buf != NULL ) &#123;        \</span></span><br><span class="line"><span class="meta">            int len = pwsprintfA( buf, STR, __VA_ARGS__ );        \</span></span><br><span class="line"><span class="meta">            pWriteConsoleA( pGetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );        \</span></span><br><span class="line"><span class="meta">            pHeapFree( pGetProcessHeap(), 0, buf );        \</span></span><br><span class="line"><span class="meta">        &#125;        \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure><p>其中用到了以下函数</p><ul><li>wsprintfA (user32.dll)</li><li>HeapFree (kernel32.dll)</li><li>RtlAllocateHeap (ntdll.dll)</li><li>GetStdHandle (kernel32.dll)</li><li>GetProcessHeap (kernel32.dll)</li><li>WriteConsoleA (kernel32.dll)</li></ul><p>另外还会用到 LoadLibraryA (kernel32.dll)，在某些情况进程中没有 user32.dll 时来加载它。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>按照声明格式写好模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span><span class="params">(WINAPI* fnLoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnHeapFree)</span><span class="params">(HANDLE hHeap, DWORD dwFlags, _Frees_ptr_opt_ LPVOID lpMem)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* fnRtlAllocateHeap)</span><span class="params">(PVOID HeapHandle, ULONG Flags, SIZE_T Size)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetStdHandle)</span><span class="params">(DWORD nStdHandle)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnWriteConsoleA)</span><span class="params">(HANDLE  hConsoleOutput, <span class="type">const</span> VOID* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID  lpReserved)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(WINAPIV* fnwsprintfA)</span><span class="params">(LPSTR unnamedParam1, LPCSTR unnamedParam2, ...)</span>;</span><br></pre></td></tr></table></figure><p>准备好 Hash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLL Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NTDLL              0x4898F593</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_USER32             0x81E3778E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_KERNEL32           0x367DC15A</span></span><br><span class="line"><span class="comment">// WIN API Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_LoadLibraryA       0x19F0EEAF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_wsprintfA          0x2AF0CBF4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapFree           0x1154459B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapAlloc          0x2F9B708A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_RtlAllocateHeap    0xF5613878</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetStdHandle       0x0C685B0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_WriteConsoleA      0x65304EA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetProcessHeap     0x3BCCFAC6</span></span><br></pre></td></tr></table></figure><p>创建全局函数指针变量，用 api_init 函数初始化所有函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">fnLoadLibraryA pLoadLibraryA;</span><br><span class="line">fnHeapFree pHeapFree;</span><br><span class="line">fnHeapAlloc pHeapAlloc;</span><br><span class="line">fnGetStdHandle pGetStdHandle;</span><br><span class="line">fnWriteConsoleA pWriteConsoleA;</span><br><span class="line">fnGetProcessHeap pGetProcessHeap;</span><br><span class="line">fnwsprintfA pwsprintfA;</span><br><span class="line">fnRtlAllocateHeap pRtlAllocateHeap;</span><br><span class="line"><span class="type">void</span> <span class="title function_">api_init</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule_Kernel32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_Kernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] K32_DLL Get Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pLoadLibraryA = (fnLoadLibraryA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA);</span><br><span class="line">pHeapFree = (fnHeapFree)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapFree);</span><br><span class="line">pHeapAlloc = (fnHeapAlloc)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapAlloc);</span><br><span class="line">pGetStdHandle = (fnGetStdHandle)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetStdHandle);</span><br><span class="line">pWriteConsoleA = (fnWriteConsoleA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_WriteConsoleA);</span><br><span class="line">pGetProcessHeap = (fnGetProcessHeap)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetProcessHeap);</span><br><span class="line"></span><br><span class="line">HMODULE hModule_User32 = Yes_GetModuleHandle_FromHash(HASH_USER32);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] U32_DLL Get Fail.\n[+] Try Load U32_DLL.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> User32_dll[] = &#123; <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_User32 = pLoadLibraryA(User32_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] U32_DLL Load Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwsprintfA = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_User32, Hash_wsprintfA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HMODULE hModule_NtDll = Yes_GetModuleHandle_FromHash(HASH_NTDLL);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] U32_DLL Get Fail.\n[+] Try Load U32_DLL.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> NtDll_dll[] = &#123; <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_NtDll = pLoadLibraryA(NtDll_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] U32_DLL Load Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pRtlAllocateHeap = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_NtDll, Hash_RtlAllocateHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了预期需求。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">api_init();</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pLLA Func Addr: 0x%p \n&quot;</span>, pLoadLibraryA);</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pRAH Func Addr: 0x%p \n&quot;</span>, pRtlAllocateHeap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数调用 api_init 对自定义 API 进行初始化，然后使用 PRINTA 宏打印信息。</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025163259037.png" class=""><p>整个项目仅需包含 <code>Windows.h</code> 头文件，来到 Pe-Bear 可以看到，Kernel32.dll 的导入表中的敏感函数导入信息已经去掉，同样加载的 User32.dll 和 NTDLL.dll 也没有显示。</p><img src="/2024/10/23/Windows%20Maldev%20-%20ITA%20%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B7%B7%E6%B7%86/image-20241025163633851.png" class=""><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>api.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>* __cdecl <span class="title function_">memset</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, <span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> intrinsic(memset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> function(memset)</span></span><br><span class="line"><span class="type">void</span>* __cdecl <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* Destination, <span class="type">int</span> Value, <span class="type">size_t</span> Size)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)Destination;</span><br><span class="line">    <span class="keyword">while</span> (Size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *p = (<span class="type">unsigned</span> <span class="type">char</span>)Value;</span><br><span class="line">        p++;</span><br><span class="line">        Size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Destination;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PVOID PAPI_SET_NAMESPACE;</span><br><span class="line"><span class="keyword">typedef</span> PVOID PACTIVATION_CONTEXT;</span><br><span class="line"><span class="keyword">typedef</span> PVOID PRTL_USER_PROCESS_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR  Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    WORD LoadCount;</span><br><span class="line">    WORD TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG TimeDateStamp;</span><br><span class="line">        PVOID LoadedImports;</span><br><span class="line">    &#125;;</span><br><span class="line">    PACTIVATION_CONTEXT EntryPointActivationContext;</span><br><span class="line">    PVOID PatchInformation;</span><br><span class="line">    LIST_ENTRY ForwarderLinks;</span><br><span class="line">    LIST_ENTRY ServiceTagLinks;</span><br><span class="line">    LIST_ENTRY StaticLinks;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span> &#123;</span></span><br><span class="line">    ULONG                   Length;</span><br><span class="line">    ULONG                   Initialized;</span><br><span class="line">    PVOID                   SsHandle;</span><br><span class="line">    LIST_ENTRY              InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY              InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY              InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    BOOLEAN InheritedAddressSpace;</span><br><span class="line">    BOOLEAN ReadImageFileExecOptions;</span><br><span class="line">    BOOLEAN BeingDebugged;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        BOOLEAN BitField;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            BOOLEAN ImageUsesLargePages : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsImageDynamicallyRelocated : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN SkipPatchingUser32Forwarders : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsPackagedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsAppContainer : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcessLight : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsLongPathAwareProcess : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    HANDLE Mutant;</span><br><span class="line">    PVOID ImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    PVOID SubSystemData;</span><br><span class="line">    PVOID ProcessHeap;</span><br><span class="line">    PRTL_CRITICAL_SECTION FastPebLock;</span><br><span class="line">    PSLIST_HEADER AtlThunkSListPtr;</span><br><span class="line">    PVOID IFEOKey;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ProcessInJob : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessInitializing : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVEH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVCH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingFTH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessPreviouslyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessCurrentlyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessImagesHotPatched : <span class="number">1</span>; <span class="comment">// REDSTONE5</span></span><br><span class="line">            ULONG ReservedBits0 : <span class="number">24</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID KernelCallbackTable;</span><br><span class="line">        PVOID UserSharedInfoPtr;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SystemReserved;</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    PAPI_SET_NAMESPACE ApiSetMap;</span><br><span class="line">    ULONG TlsExpansionCounter;</span><br><span class="line">    PVOID TlsBitmap;</span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    PVOID ReadOnlySharedMemoryBase;</span><br><span class="line">    PVOID SharedData;                   <span class="comment">// HotpatchInformation</span></span><br><span class="line">    PVOID* ReadOnlyStaticServerData;</span><br><span class="line">    PVOID AnsiCodePageData;             <span class="comment">// PCPTABLEINFO</span></span><br><span class="line">    PVOID OemCodePageData;              <span class="comment">// PCPTABLEINFO</span></span><br><span class="line">    PVOID UnicodeCaseTableData;         <span class="comment">// PNLSTABLEINFO</span></span><br><span class="line">    ULONG NumberOfProcessors;</span><br><span class="line">    ULONG NtGlobalFlag;</span><br><span class="line">    ULARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    SIZE_T HeapSegmentReserve;</span><br><span class="line">    SIZE_T HeapSegmentCommit;</span><br><span class="line">    SIZE_T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    SIZE_T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    ULONG NumberOfHeaps;</span><br><span class="line">    ULONG MaximumNumberOfHeaps;</span><br><span class="line">    PVOID* ProcessHeaps;                <span class="comment">// PHEAP</span></span><br><span class="line">    PVOID GdiSharedHandleTable;</span><br><span class="line">    PVOID ProcessStarterHelper;</span><br><span class="line">    ULONG GdiDCAttributeList;</span><br><span class="line">    PRTL_CRITICAL_SECTION LoaderLock;</span><br><span class="line">    ULONG OSMajorVersion;</span><br><span class="line">    ULONG OSMinorVersion;</span><br><span class="line">    USHORT OSBuildNumber;</span><br><span class="line">    USHORT OSCSDVersion;</span><br><span class="line">    ULONG OSPlatformId;</span><br><span class="line">    ULONG ImageSubsystem;</span><br><span class="line">    ULONG ImageSubsystemMajorVersion;</span><br><span class="line">    ULONG ImageSubsystemMinorVersion;</span><br><span class="line">    KAFFINITY ActiveProcessAffinityMask;</span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">60</span>];</span><br><span class="line">    PVOID PostProcessInitRoutine;</span><br><span class="line">    PVOID TlsExpansionBitmap;</span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    PVOID pShimData;</span><br><span class="line">    PVOID AppCompatInfo;                        <span class="comment">// APPCOMPAT_EXE_DATA</span></span><br><span class="line">    UNICODE_STRING CSDVersion;</span><br><span class="line">    PVOID ActivationContextData;                <span class="comment">// ACTIVATION_CONTEXT_DATA</span></span><br><span class="line">    PVOID ProcessAssemblyStorageMap;            <span class="comment">// ASSEMBLY_STORAGE_MAP</span></span><br><span class="line">    PVOID SystemDefaultActivationContextData;   <span class="comment">// ACTIVATION_CONTEXT_DATA</span></span><br><span class="line">    PVOID SystemAssemblyStorageMap;             <span class="comment">// ASSEMBLY_STORAGE_MAP</span></span><br><span class="line">    SIZE_T MinimumStackCommit;</span><br><span class="line">    PVOID SparePointers[<span class="number">2</span>];                     <span class="comment">// 19H1 (previously FlsCallback to FlsHighIndex)</span></span><br><span class="line">    PVOID PatchLoaderData;</span><br><span class="line">    PVOID ChpeV2ProcessInfo;                    <span class="comment">// _CHPEV2_PROCESS_INFO</span></span><br><span class="line">    ULONG AppModelFeatureState;</span><br><span class="line">    ULONG SpareUlongs[<span class="number">2</span>];</span><br><span class="line">    USHORT ActiveCodePage;</span><br><span class="line">    USHORT OemCodePage;</span><br><span class="line">    USHORT UseCaseMapping;</span><br><span class="line">    USHORT UnusedNlsField;</span><br><span class="line">    PVOID WerRegistrationData;</span><br><span class="line">    PVOID WerShipAssertPtr;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID pContextData; <span class="comment">// WIN7</span></span><br><span class="line">        PVOID pUnused; <span class="comment">// WIN10</span></span><br><span class="line">        PVOID EcCodeBitMap; <span class="comment">// WIN11</span></span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID pImageHeaderHash;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG TracingFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG CritSecTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG LibLoaderTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG SpareTracingBits : <span class="number">29</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONGLONG CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">    PRTL_CRITICAL_SECTION TppWorkerpListLock;</span><br><span class="line">    LIST_ENTRY TppWorkerpList;</span><br><span class="line">    PVOID WaitOnAddressHashTable[<span class="number">128</span>];</span><br><span class="line">    PVOID TelemetryCoverageHeader;              <span class="comment">// REDSTONE3</span></span><br><span class="line">    ULONG CloudFileFlags;</span><br><span class="line">    ULONG CloudFileDiagFlags;                   <span class="comment">// REDSTONE4</span></span><br><span class="line">    CHAR PlaceholderCompatibilityMode;</span><br><span class="line">    CHAR PlaceholderCompatibilityModeReserved[<span class="number">7</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LEAP_SECOND_DATA</span>* <span class="title">LeapSecondData</span>;</span>   <span class="comment">// REDSTONE5</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG LeapSecondFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG SixtySecondEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG Reserved : <span class="number">31</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG NtGlobalFlag2;</span><br><span class="line">    ULONGLONG ExtendedFeatureDisableMask; <span class="comment">// since WIN11</span></span><br><span class="line">&#125; PEB, * PPEB;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))</span></span><br><span class="line">UINT32 <span class="title function_">HashStringJenkinsOneAtATime32BitA</span><span class="params">(IN PCHAR String)</span> &#123;</span><br><span class="line">    SIZE_T Index = <span class="number">0</span>;</span><br><span class="line">    UINT32 Hash = <span class="number">0</span>;</span><br><span class="line">    SIZE_T Length = <span class="built_in">strlen</span>(String);</span><br><span class="line">    <span class="keyword">while</span> (Index != Length) &#123;</span><br><span class="line">        Hash += String[Index++];</span><br><span class="line">        Hash += Hash &lt;&lt; <span class="number">7</span>; <span class="comment">// seed</span></span><br><span class="line">        Hash ^= Hash &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Hash += Hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    Hash ^= Hash &gt;&gt; <span class="number">11</span>;</span><br><span class="line">    Hash += Hash &lt;&lt; <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">return</span> Hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_MAX_PATH256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TO_UPPER(C) C &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; C &lt;= <span class="string">&#x27;z&#x27;</span> ? C + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span> : C</span></span><br><span class="line">HMODULE <span class="title function_">Yes_GetModuleHandle_FromHash</span><span class="params">(IN UINT32 ui32DllHash)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64<span class="comment">// 获取 x64 peb</span></span></span><br><span class="line">    PPEB            pPeb = (PEB*)(__readgsqword(<span class="number">0x60</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32<span class="comment">// 获取 x86 peb</span></span></span><br><span class="line">    PPEB            pPeb = (PEB*)(__readfsdword(<span class="number">0x30</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);<span class="comment">// 获取 Ldr</span></span><br><span class="line">    PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line">    <span class="keyword">while</span> (pDte-&gt;FullDllName.Length != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        CHAR UpperCaseDllName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pDte-&gt;FullDllName.Length; i++)<span class="comment">// 转化成大写</span></span><br><span class="line">            UpperCaseDllName[i] = (CHAR)TO_UPPER(pDte-&gt;FullDllName.Buffer[i]);</span><br><span class="line">        <span class="keyword">if</span> (ui32DllHash == HASHA(UpperCaseDllName))<span class="comment">// 判断 Hash 是否一致</span></span><br><span class="line">            <span class="keyword">return</span> pDte-&gt;InInitializationOrderLinks.Flink;<span class="comment">// 返回 DLL Base Address</span></span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);<span class="comment">// 链表下一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress_FromHash</span><span class="params">(IN HMODULE hModule, IN UINT32 ui32FuncHash)</span> &#123;</span><br><span class="line">    PBYTE pBase = (PBYTE)hModule;<span class="comment">// 转化一下</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;<span class="comment">// 获取 DOS 头</span></span><br><span class="line">    <span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);<span class="comment">// 获取 NT 头</span></span><br><span class="line">    <span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)<span class="comment">// 签名检查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;<span class="comment">// 获取可选头</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<span class="comment">// 获取导出目录</span></span><br><span class="line">    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);<span class="comment">// 获取函数名称数组指针</span></span><br><span class="line">    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);<span class="comment">// 获取函数地址数组指针</span></span><br><span class="line">    PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);<span class="comment">// 获取函数序号数组指针</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++)</span><br><span class="line">        <span class="keyword">if</span> (HASHA(pBase + FunctionNameArray[i]) == ui32FuncHash)<span class="comment">// 比较函数名的 Hash</span></span><br><span class="line">            <span class="keyword">return</span> (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);<span class="comment">// 通过函数序数值获取函数地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTA( STR, ... )\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (1) &#123;\</span></span><br><span class="line"><span class="meta">        LPSTR buf = (LPSTR)pRtlAllocateHeap(pGetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ( buf != NULL ) &#123;\</span></span><br><span class="line"><span class="meta">            int len = pwsprintfA( buf, STR, __VA_ARGS__ );\</span></span><br><span class="line"><span class="meta">            pWriteConsoleA( pGetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );\</span></span><br><span class="line"><span class="meta">            pHeapFree( pGetProcessHeap(), 0, buf );\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line">UINT32 <span class="title function_">HashStringJenkinsOneAtATime32BitA</span><span class="params">(IN PCHAR String)</span>;</span><br><span class="line">HMODULE <span class="title function_">Yes_GetModuleHandle_FromHash</span><span class="params">(IN UINT32 ui32DllHash)</span>;</span><br><span class="line">FARPROC <span class="title function_">Yes_GetProcAddress_FromHash</span><span class="params">(IN HMODULE hModule, IN UINT32 ui32FuncHash)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NTDLL              0x4898F593</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_USER32             0x81E3778E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_KERNEL32           0x367DC15A</span></span><br><span class="line"><span class="comment">// WIN API Name Hash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_LoadLibraryA       0x19F0EEAF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_wsprintfA          0x2AF0CBF4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapFree           0x1154459B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_HeapAlloc          0x2F9B708A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_RtlAllocateHeap    0xF5613878</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetStdHandle       0x0C685B0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_WriteConsoleA      0x65304EA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash_GetProcessHeap     0x3BCCFAC6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span><span class="params">(WINAPI* fnLoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnHeapFree)</span><span class="params">(HANDLE hHeap, DWORD dwFlags, _Frees_ptr_opt_ LPVOID lpMem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* fnHeapAlloc)</span><span class="params">(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlallocateheap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* fnRtlAllocateHeap)</span><span class="params">(PVOID HeapHandle, ULONG Flags, SIZE_T Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-getprocessheap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/console/getstdhandle</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetStdHandle)</span><span class="params">(DWORD nStdHandle)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/console/writeconsole</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* fnWriteConsoleA)</span><span class="params">(HANDLE  hConsoleOutput, <span class="type">const</span> VOID* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID  lpReserved)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-getprocessheap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* fnGetProcessHeap)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-wsprintfw</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(WINAPIV* fnwsprintfA)</span><span class="params">(LPSTR unnamedParam1, LPCSTR unnamedParam2, ...)</span>;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_NUM 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC_NUM 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showHash</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">char</span>* dllList[DLL_NUM] = &#123;</span><br><span class="line"><span class="string">&quot;NTDLL.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;USER32.DLL&quot;</span>,</span><br><span class="line"><span class="string">&quot;KERNEL32.DLL&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span>* funcList[FUNC_NUM] = &#123;</span><br><span class="line"><span class="string">&quot;LoadLibraryA&quot;</span>,</span><br><span class="line"><span class="string">&quot;wsprintfA&quot;</span>,</span><br><span class="line"><span class="string">&quot;HeapFree&quot;</span>,</span><br><span class="line"><span class="string">&quot;HeapAlloc&quot;</span>,</span><br><span class="line"><span class="string">&quot;RtlAllocateHeap&quot;</span>,</span><br><span class="line"><span class="string">&quot;GetStdHandle&quot;</span>,</span><br><span class="line"><span class="string">&quot;WriteConsoleA&quot;</span>,</span><br><span class="line"><span class="string">&quot;GetProcessHeap&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span>* funcSysList[] = &#123;</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// DLL Name Hash\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DLL_NUM; i++) &#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define HASH_&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; dllList[i][j] != <span class="string">&#x27;.&#x27;</span>; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dllList[i][j]);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t0x%0.8X \n&quot;</span>, HASHA(dllList[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// WIN API Name Hash\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FUNC_NUM; i++) &#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define Hash_%s&quot;</span>, funcList[i]);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; funcList[i][j] != <span class="string">&#x27;\x00&#x27;</span>; j++);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">5</span> &lt; <span class="number">24</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%0.8X \n&quot;</span>, HASHA(funcList[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule_Kernel32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_Kernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] K32_DLL Get Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n[+] Get DLL KERNEL32\t: 0x%p \n+------------------------------------------+\n&quot;</span>, hModule_Kernel32);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] LLA func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] HFr func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapFree));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] HAl func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapAlloc));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] GSH func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetStdHandle));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] WCA func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_WriteConsoleA));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] GPH func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetProcessHeap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE hModule_User32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] U32_DLL Get Fail.\n[+] Try Load U32_DLL.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> User32_dll[] = &#123; <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_User32 = (fnLoadLibraryA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA)(User32_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] U32_DLL Load Fail. \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n[+] Load DLL USER32\t: 0x%p \n+------------------------------------------+\n&quot;</span>, hModule_User32);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n[+] Get DLL USER32\t: 0x%p \n+------------------------------------------+\n&quot;</span>, hModule_User32);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] wpf func address\t: 0x%p \n&quot;</span>, Yes_GetProcAddress_FromHash(hModule_User32, Hash_wsprintfA));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+------------------------------------------+\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">fnLoadLibraryA pLoadLibraryA;</span><br><span class="line">fnHeapFree pHeapFree;</span><br><span class="line">fnHeapAlloc pHeapAlloc;</span><br><span class="line">fnGetStdHandle pGetStdHandle;</span><br><span class="line">fnWriteConsoleA pWriteConsoleA;</span><br><span class="line">fnGetProcessHeap pGetProcessHeap;</span><br><span class="line">fnwsprintfA pwsprintfA;</span><br><span class="line">fnRtlAllocateHeap pRtlAllocateHeap;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">api_init</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule_Kernel32 = Yes_GetModuleHandle_FromHash(HASH_KERNEL32);</span><br><span class="line"><span class="keyword">if</span> (hModule_Kernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pLoadLibraryA = (fnLoadLibraryA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_LoadLibraryA);</span><br><span class="line">pHeapFree = (fnHeapFree)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapFree);</span><br><span class="line">pHeapAlloc = (fnHeapAlloc)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_HeapAlloc);</span><br><span class="line">pGetStdHandle = (fnGetStdHandle)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetStdHandle);</span><br><span class="line">pWriteConsoleA = (fnWriteConsoleA)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_WriteConsoleA);</span><br><span class="line">pGetProcessHeap = (fnGetProcessHeap)Yes_GetProcAddress_FromHash(hModule_Kernel32, Hash_GetProcessHeap);</span><br><span class="line"></span><br><span class="line">HMODULE hModule_User32 = Yes_GetModuleHandle_FromHash(HASH_USER32);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">char</span> User32_dll[] = &#123; <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_User32 = pLoadLibraryA(User32_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_User32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwsprintfA = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_User32, Hash_wsprintfA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HMODULE hModule_NtDll = Yes_GetModuleHandle_FromHash(HASH_NTDLL);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">char</span> NtDll_dll[] = &#123; <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line">hModule_NtDll = pLoadLibraryA(NtDll_dll);</span><br><span class="line"><span class="keyword">if</span> (hModule_NtDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pRtlAllocateHeap = (fnwsprintfA)Yes_GetProcAddress_FromHash(hModule_NtDll, Hash_RtlAllocateHeap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">showHash();</span><br><span class="line">test();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">api_init();</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pLLA Func Addr: 0x%p \n&quot;</span>, pLoadLibraryA);</span><br><span class="line">PRINTA(<span class="string">&quot;[+] pRAH Func Addr: 0x%p \n&quot;</span>, pRtlAllocateHeap);</span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good Luck.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Maldev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 恶意软件开发</title>
      <link href="/2024/10/08/Windows%20%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2024/10/08/Windows%20%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows 下的恶意软件一般包含以下功能</p><ul><li><input disabled="" type="checkbox"> Payload 存储、加密、混淆、执行</li><li><input disabled="" type="checkbox"> PE 信息伪造、进程信息伪造</li><li><input disabled="" type="checkbox"> 沙箱检测、虚拟环境检测</li><li><input disabled="" type="checkbox"> 反调试、杀软绕过</li><li><input disabled="" type="checkbox"> EDR 绕过</li></ul><h2 id="Payload-存储"><a href="#Payload-存储" class="headerlink" title="Payload 存储"></a>Payload 存储</h2><p>目前有以下存储方式</p><ul><li>PE 文件内部<ul><li>.data .rdata 段</li><li>.text 段</li><li>.rsrc 段</li></ul></li><li>本地 Payload 分离<ul><li>可以起一个伪装的名称，config.xml、resources.pak…</li></ul></li><li>远程 Payload<ul><li><a href="https://xxx.com/favicon.ico">https://xxx.com/favicon.ico</a></li><li><a href="http://xxx.com/uploads/images/head.png">http://xxx.com/uploads/images/head.png</a></li></ul></li><li>Windows 注册表</li></ul><p>三种方法各有优劣，应根据实际应用场景进行选择。例如：</p><ul><li>在权限维持场景中，可以优先考虑 Payload 分离；</li><li>在社工钓鱼的场景中，可以优先考虑远程文件的方式，这样可以在钓鱼行动被发现后更改远程 Payload 内容；</li><li>在多层内网环境或者存在离线环境的情况下，就优先考虑在 PE 文件内部存储 Payload，这样会让蓝队不那么容易去追踪感染链。</li></ul><h3 id="PE-文件内部存储"><a href="#PE-文件内部存储" class="headerlink" title="PE 文件内部存储"></a>PE 文件内部存储</h3><ul><li><input disabled="" type="checkbox"> .data 段主要包含初始化的全局和静态变量，可读可写；.rdata 段存放常量，只读。一个较小的程序需要初始化一个较大的变量，这种行为看起来多少会有些奇怪。</li><li><input disabled="" type="checkbox"> .text 段具有可执行权限，存储在其中的数据可以直接执行，因此这个段需要接受的审查会更严格，如果 Payload 较小（小于 10 字节），那么放在此段效果会很好。</li><li><input checked="" disabled="" type="checkbox"> .rsrc 段主要放置资源文件，实际情况下大部分的二进制文件都会在此存放数据，所以 Payload 可以未造成图标或者其他文件存储在这里。</li></ul><h3 id="Payload-分离"><a href="#Payload-分离" class="headerlink" title="Payload 分离"></a>Payload 分离</h3><p>Payload 分离，需要考虑的问题就是如何伪装，可以根据普通应用程序的内容来模仿。</p><ul><li>Windows 注册表</li><li>游戏资源文件</li><li>主题文件</li><li>chm 手册</li><li>pak、v8 文件（主要是一些基于浏览器打包的应用程序）</li><li>ui 文件</li><li>dll 文件</li></ul><h3 id="远程-Payload"><a href="#远程-Payload" class="headerlink" title="远程 Payload"></a>远程 Payload</h3><p>本质上也是对 Payload 进行分离，所以需要考虑的内容也是如何伪装</p><ul><li>图标资源</li><li>API 请求</li><li>…</li></ul><h2 id="Payload-加密"><a href="#Payload-加密" class="headerlink" title="Payload 加密"></a>Payload 加密</h2><ul><li><input disabled="" type="checkbox"> XOR</li><li><input disabled="" type="checkbox"> RC4</li><li><input checked="" disabled="" type="checkbox"> AES</li></ul><p>XOR、RC4 加密已经无法绕过 Windows Defender 了，建议使用 AES 或者其他强加密方法。</p><h2 id="Payload-混淆"><a href="#Payload-混淆" class="headerlink" title="Payload 混淆"></a>Payload 混淆</h2><ul><li><input checked="" disabled="" type="checkbox"> IPv4&#x2F;IPv6</li><li><input checked="" disabled="" type="checkbox"> MAC</li><li><input checked="" disabled="" type="checkbox"> UUID</li></ul><p>三种方法可以结合应用场景进行选择。例如：Payload 分离的存储方式可以搭配 MAC 混淆，将 Payload 存储在 xml 等文件中。</p><h2 id="Payload-执行"><a href="#Payload-执行" class="headerlink" title="Payload 执行"></a>Payload 执行</h2><ul><li><input disabled="" type="checkbox"> 本地&#x2F;远程 DLL 加载</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程进程执行</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程线程创建</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程线程劫持</li><li><input disabled="" type="checkbox"> APC 注入</li><li><input disabled="" type="checkbox"> 回调代码执行</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程映射注入</li><li><input disabled="" type="checkbox"> 本地&#x2F;远程函数篡改</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Windows </tag>
            
            <tag> C </tag>
            
            <tag> 恶意软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog 解决方案</title>
      <link href="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前的解决方案：Hexo &amp; cactus + Github Action</p></blockquote><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>Blog 采用 Hexo 引擎 cactus 主题，并对主题做了些微改动</p><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><blockquote><p>我这里使用的是 Node.js 18.x 版本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"><span class="comment"># 创建私有 github 仓库 https://github.com/[youname]/blog.git</span></span><br><span class="line"><span class="comment"># 想知道如何 clone/push/pull 私有仓库，去网上搜搜吧</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/[your_name]/blog.git</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 初始化 blog</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/probberechts/hexo-theme-cactus.git themes/cactus</span><br></pre></td></tr></table></figure><ul><li>编辑 blog&#x2F;_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&#x27;标题&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;站点简介&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&#x27;作者名称&#x27;</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"># 我这里使用的是 github pages 的一个子目录</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">&#x27;https://[your_name].github.io/&#x27;</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">cactus</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 其他可以保持默认</span></span><br></pre></td></tr></table></figure><ul><li>编辑 <code>blog/theme/cactus/_config.yml</code>，配置内容参考作者提供的文档即可</li></ul><blockquote><p><a href="https://github.com/probberechts/hexo-theme-cactus">https://github.com/probberechts/hexo-theme-cactus</a></p></blockquote><h3 id="Github-Action-自动化发布"><a href="#Github-Action-自动化发布" class="headerlink" title="Github Action 自动化发布"></a>Github Action 自动化发布</h3><ul><li>编辑 .github&#x2F;workflows&#x2F;hexo.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">hexo-ci</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permissions:</span></span><br><span class="line">  <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">使用</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">          </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装搜索</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-search</span> <span class="string">--save</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">markdown</span> <span class="string">图片索引</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-image-link</span> <span class="string">--save</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">        </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">发布到公共仓库</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLISH_BLOG</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">          <span class="attr">destination_dir:</span> <span class="string">blog</span></span><br><span class="line">          <span class="attr">external_repository:</span> [<span class="string">your_name</span>]<span class="string">/[your_name].github.io</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>我这里是跨仓库发布，因此需要一个 TOKEN，上面我命名的这个 <code>secrets.PUBLISH_BLOG</code></p><p>登录 Github 之后，打开 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 页面</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929150803.png" class=""><ol><li>这里的 Note 可以随便设置，是用于区分 token 的，以便于看到后可以快速回忆起，建议设置成仓库名：Blog_token</li><li>Expiration 是可以时间，我嫌麻烦一般设置成永久，安全起见可以设置成 90 天，然后过期再更新</li><li>下面的作用范围只需要勾选 workflow 就行，会自动选中 repo 权限</li></ol><p>生成后会得到一个密钥，先复制下来待会要用</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151040.png" class=""><p>打开 <a href="https://github.com/fermionorz/blog/settings/secrets/actions/new">https://github.com/fermionorz/blog/settings/secrets/actions/new</a> 页面，添加刚刚复制的密钥</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151247.png" class=""><p>添加成功后的效果</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151323.png" class=""><p>这里就没问题了，这个时候每次对仓库进行提交，都会自动把内容发布到 <code>[your_name]/[your_name].github.io</code> 仓库的 <code>blog</code> 目录中</p><p>然后可以转到 <code>[your_name].github.io</code> 仓库看到了</p><img src="/2024/09/29/Blog%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20240929151818.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> Site </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
